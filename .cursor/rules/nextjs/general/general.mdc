---
description: Next.js general development guidelines and best practices
globs:
- '**/*.js'
- '**/*.jsx'
- '**/*.ts'
- '**/*.tsx'
- '**/next.config.*'
- '**/middleware.ts'
- '**/app/**/*'
- '**/pages/**/*'
- '**/components/**/*'
- '**/lib/**/*'
- '**/utils/**/*'
alwaysApply: false
tags:
- css-in-js
- lazy-loading
- optimizing
- api-reference
- tailwind-css
- client-components
- data-fetching
- 'https:'
- app
- functions
version: 1.0.0
lastUpdated: '2025-09-03T06:13:27.379004'
---
# General Development Rules
*Generated on 2025-09-03 06:13:27*
## Overview
Next.js general development guidelines and best practices
**Difficulty Level**: Beginner
**Category**: general

## 1. Next.js Docs | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 2. App Router: Getting Started | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
create-next-app
```

---

## 3. Getting Started: Installation | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 4. Next.js Docs: App Router | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
create-next-app
```

---

## 5. Next.js Docs: Pages Router | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 6. Getting Started: Layouts and Pages | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
/blog/ ${ post .slug } 
```

---

## 7. Building Your Application: Routing | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 8. Getting Started: Linking and Navigating | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
link-hint ${ pending ? 'is-pending' : '' } 
```

```typescript
? ${ params .toString () } 
```

```typescript
/ ${ locale }${ pathname } 
```

### Anti-Patterns
- ❌ unnecessary usage of resources when rendering large lists of links (e.g. an infinite scroll table). < Link prefetch = { false } href = "/blog" > Blog </ Link > However, disabling prefetching comes with trade-offs: Static routes will only be fetched when the user clicks the link. Dynamic routes will need to be rendered on the server first before the client can navigate to it. To reduce resource usage without fully disabling prefetch, you can prefetch only on hover. This limits prefetching to routes the user is more likely to visit, rather than all links in the viewport. app/ui/hover-prefetch-link.tsx TypeScript JavaScript TypeScript 'use client' import Link from 'next/link' import { useState } from 'react' function HoverPrefetchLink ({ href , children , } : { href : string children : React . ReactNode }) { const [ active , setActive ] = useState ( false ) return ( < Link href = {href} prefetch = {active ? null : false } onMouseEnter = {() => setActive ( true )} > {children} </ Link > ) } Hydration not completed <Link> is a Client Component and must be hydrated before it can prefetch routes. On the initial visit, large JavaScript bundles can delay hydration, preventing prefetching from starting right away. React mitigates this with Selective Hydration and you can further improve this by: Using the @next/bundle-analyzer plugin to identify and reduce bundle size by removing large dependencies. Moving logic from the client to the server where possible. See the Server and Client Components docs for guidance. Examples Native History API Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page. pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams . window.history.pushState Use it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products: 'use client' import { useSearchParams } from 'next/navigation' export default function SortProducts () { const searchParams = useSearchParams () function updateSorting (sortOrder : string ) { const params = new URLSearchParams ( searchParams .toString ()) params .set ( 'sort' , sortOrder) window . history .pushState ( null , '' , `? ${ params .toString () } ` ) } return ( <> < button onClick = {() => updateSorting ( 'asc' )}>Sort Ascending</ button > < button onClick = {() => updateSorting ( 'desc' )}>Sort Descending</ button > </> ) } window.history.replaceState Use it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale: 'use client' import { usePathname } from 'next/navigation' export function LocaleSwitcher () { const pathname = usePathname () function switchLocale (locale : string ) { // e.g. '/en/about' or '/fr/contact' const newPath = `/ ${ locale }${ pathname } ` window . history .replaceState ( null , '' , newPath) } return ( <> < button onClick = {() => switchLocale ( 'en' )}>English</ button > < button onClick = {() => switchLocale ( 'fr' )}>French</ button > </> ) } Next Steps Link Component Enable fast client-side navigation with the built-in `next/link` component. loading.js API reference for the loading.js file. Prefetching Learn how to configure prefetching in Next.js Previous Layouts and Pages Next Server and Client Components Was this helpful? supported. Send
- ❌ visit. However, waiting for a server response before navigation can give the users the impression that the app is not responding. To improve the navigation experience to dynamic routes, you can use streaming . Streaming Streaming allows the server to send parts of a dynamic route to the client as soon as they're ready, rather than waiting for the entire route to be rendered. This means users see something sooner, even if parts of the page are still loading. For dynamic routes, it means they can be partially prefetched . That is, shared layouts and loading skeletons can be requested ahead of time. To use streaming, create a loading.tsx in your route folder: app/dashboard/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { // Add fallback UI that will be shown while the route is loading. return < LoadingSkeleton /> } Behind the scenes, Next.js will automatically wrap the page.tsx contents in a <Suspense> boundary. The prefetched fallback UI will be shown while the route is loading, and swapped for the actual content once ready. Good to know : You can also use <Suspense> to create loading UI for nested components. Benefits of loading.tsx : Immediate navigation and visual feedback for the user. Shared layouts remain interactive and navigation is interruptible. Improved Core Web Vitals: TTFB , FCP , and TTI . To further improve the navigation experience, Next.js performs a client-side transition with the <Link> component. Client-side transitions Traditionally, navigation to a server-rendered page triggers a full page load. This clears state, resets scroll position, and blocks interactivity. Next.js avoids this with client-side transitions using the <Link> component. Instead of reloading the page, it updates the content dynamically by: Keeping any shared layouts and UI. Replacing the current page with the prefetched loading state or a new page if available. Client-side transitions are what makes a server-rendered apps feel like client-rendered apps. And when paired with prefetching and streaming , it enables fast transitions, even for dynamic routes. What can make transitions slow? These Next.js optimizations make navigation fast and responsive. However, under certain conditions, transitions can still feel slow. Here are some common causes and how to improve the user experience: Dynamic routes without loading.tsx When navigating to a dynamic route, the client must wait for the server response before showing the result. This can give the users the impression that the app is not responding. We recommend adding loading.tsx to dynamic routes to enable partial prefetching, trigger immediate navigation, and display a loading UI while the route renders. app/blog/[slug]/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { return < LoadingSkeleton /> } Good to know : In development mode, you can use the Next.js Devtools to identify if the route is static or dynamic. See devIndicators for more information. Dynamic segments without generateStaticParams If a dynamic segment could be prerendered but isn't because it's missing generateStaticParams , the route will fallback to dynamic rendering at request time. Ensure the route is statically generated at build time by adding generateStaticParams : app/blog/[slug]/page.tsx TypeScript JavaScript TypeScript export async function generateStaticParams () { const posts = await fetch ( 'https://.../posts' ) .then ((res) => res .json ()) return posts .map ((post) => ({ slug : post .slug , })) } export default async function Page ({ params , } : { params : Promise <{ slug : string }> }) { const { slug } = await params // ... } Slow networks On slow or unstable networks, prefetching may not finish before the user clicks a link. This can affect both static and dynamic routes. In these cases, the loading.js fallback may not appear immediately because it hasn't been prefetched yet. To improve perceived performance, you can use the useLinkStatus hook to show immediate feedback while the transition is in progress. app/ui/loading-indicator.tsx TypeScript JavaScript TypeScript 'use client' import { useLinkStatus } from 'next/link' export default function LoadingIndicator () { const { pending } = useLinkStatus () return ( < span aria-hidden className = { `link-hint ${ pending ? 'is-pending' : '' } ` } /> ) } You can "debounce" the hint by adding an initial animation delay (e.g. 100ms) and starting as invisible (e.g. opacity: 0 ). This means the loading indicator will only be shown if the navigation takes longer than the specified delay. See the useLinkStatus reference for a CSS example. Good to know : You can use other visual feedback patterns like a progress bar. View an example here . Disabling prefetching You can opt out of prefetching by setting the prefetch prop to false on the <Link> component. This is useful to avoid unnecessary usage of resources when rendering large lists of links (e.g. an infinite scroll table). < Link prefetch = { false } href = "/blog" > Blog </ Link > However, disabling prefetching comes with trade-offs: Static routes will only be fetched when the user clicks the link. Dynamic routes will need to be rendered on the server first before the client can navigate to it. To reduce resource usage without fully disabling prefetch, you can prefetch only on hover. This limits prefetching to routes the user is more likely to visit, rather than all links in the viewport. app/ui/hover-prefetch-link.tsx TypeScript JavaScript TypeScript 'use client' import Link from 'next/link' import { useState } from 'react' function HoverPrefetchLink ({ href , children , } : { href : string children : React . ReactNode }) { const [ active , setActive ] = useState ( false ) return ( < Link href = {href} prefetch = {active ? null : false } onMouseEnter = {() => setActive ( true )} > {children} </ Link > ) } Hydration not completed <Link> is a Client Component and must be hydrated before it can prefetch routes. On the initial visit, large JavaScript bundles can delay hydration, preventing prefetching from starting right away. React mitigates this with Selective Hydration and you can further improve this by: Using the @next/bundle-analyzer plugin to identify and reduce bundle size by removing large dependencies. Moving logic from the client to the server where possible. See the Server and Client Components docs for guidance. Examples Native History API Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page. pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams . window.history.pushState Use it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products: 'use client' import { useSearchParams } from 'next/navigation' export default function SortProducts () { const searchParams = useSearchParams () function updateSorting (sortOrder : string ) { const params = new URLSearchParams ( searchParams .toString ()) params .set ( 'sort' , sortOrder) window . history .pushState ( null , '' , `? ${ params .toString () } ` ) } return ( <> < button onClick = {() => updateSorting ( 'asc' )}>Sort Ascending</ button > < button onClick = {() => updateSorting ( 'desc' )}>Sort Descending</ button > </> ) } window.history.replaceState Use it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale: 'use client' import { usePathname } from 'next/navigation' export function LocaleSwitcher () { const pathname = usePathname () function switchLocale (locale : string ) { // e.g. '/en/about' or '/fr/contact' const newPath = `/ ${ locale }${ pathname } ` window . history .replaceState ( null , '' , newPath) } return ( <> < button onClick = {() => switchLocale ( 'en' )}>English</ button > < button onClick = {() => switchLocale ( 'fr' )}>French</ button > </> ) } Next Steps Link Component Enable fast client-side navigation with the built-in `next/link` component. loading.js API reference for the loading.js file. Prefetching Learn how to configure prefetching in Next.js Previous Layouts and Pages Next Server and Client Components Was this helpful? supported. Send

---

## 9. File-system conventions: middleware.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
 ${ req . nextUrl .pathname } /
```

```typescript
RequestCookies
```

```typescript
ResponseCookies
```

```typescript
Set-Cookie:vercel=fast;path=/
```

```typescript
x-hello-from-middleware1
```

### Anti-Patterns
- ❌ setting large headers as it might cause 431 Request Header Fields Too Large error depending on your backend web server configuration. CORS You can set CORS headers in Middleware to allow cross-origin requests, including simple and preflighted requests. middleware.ts TypeScript JavaScript TypeScript import { NextRequest , NextResponse } from 'next/server' const allowedOrigins = [ 'https://acme.com' , 'https://my-app.org' ] const corsOptions = { 'Access-Control-Allow-Methods' : 'GET, POST, PUT, DELETE, OPTIONS' , 'Access-Control-Allow-Headers' : 'Content-Type, Authorization' , } export function middleware (request : NextRequest ) { // Check the origin from the request const origin = request . headers .get ( 'origin' ) ?? '' const isAllowedOrigin = allowedOrigins .includes (origin) // Handle preflighted requests const isPreflight = request .method === 'OPTIONS' if (isPreflight) { const preflightHeaders = { ... (isAllowedOrigin && { 'Access-Control-Allow-Origin' : origin }) , ... corsOptions , } return NextResponse .json ({} , { headers : preflightHeaders }) } // Handle simple requests const response = NextResponse .next () if (isAllowedOrigin) { response . headers .set ( 'Access-Control-Allow-Origin' , origin) } Object .entries (corsOptions) .forEach (([key , value]) => { response . headers .set (key , value) }) return response } export const config = { matcher : '/api/:path*' , } Good to know: You can configure CORS headers for individual routes in Route Handlers . Producing a response You can respond from Middleware directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0 ) middleware.ts TypeScript JavaScript TypeScript import type { NextRequest } from 'next/server' import { isAuthenticated } from '@lib/auth' // Limit the middleware to paths starting with `/api/` export const config = { matcher : '/api/:function*' , } export function middleware (request : NextRequest ) { // Call our authentication function to check the request if ( ! isAuthenticated (request)) { // Respond with JSON indicating an error message return Response .json ( { success : false , message : 'authentication failed' } , { status : 401 } ) } } Negative matching The matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here: middleware.js export const config = { matcher : [ /* * Match all request paths except for the ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico, sitemap.xml, robots.txt (metadata files) */ '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)' , ] , } You can also bypass Middleware for certain requests by using the missing or has arrays, or a combination of both: middleware.js export const config = { matcher : [ /* * Match all request paths except for the ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico, sitemap.xml, robots.txt (metadata files) */ { source : '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)' , missing : [ { type : 'header' , key : 'next-router-prefetch' } , { type : 'header' , key : 'purpose' , value : 'prefetch' } , ] , } , { source : '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)' , has : [ { type : 'header' , key : 'next-router-prefetch' } , { type : 'header' , key : 'purpose' , value : 'prefetch' } , ] , } , { source : '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)' , has : [{ type : 'header' , key : 'x-present' }] , missing : [{ type : 'header' , key : 'x-missing' , value : 'prefetch' }] , } , ] , } waitUntil and NextFetchEvent The NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method. The waitUntil() method takes a promise as an argument, and extends the lifetime of the Middleware until the promise settles. This is useful for performing work in the background. middleware.ts import { NextResponse } from 'next/server' import type { NextFetchEvent , NextRequest } from 'next/server' export function middleware (req : NextRequest , event : NextFetchEvent ) { event .waitUntil ( fetch ( 'https://my-analytics-platform.com' , { method : 'POST' , body : JSON .stringify ({ pathname : req . nextUrl .pathname }) , }) ) return NextResponse .next () } Unit testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test middleware files. Unit testing middleware can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production. The unstable_doesMiddlewareMatch function can be used to assert whether middleware will run for the provided URL, headers, and cookies. import { unstable_doesMiddlewareMatch } from 'next/experimental/testing/server' expect ( unstable_doesMiddlewareMatch ({ config , nextConfig , url : '/test' , }) ) .toEqual ( false ) The entire middleware function can also be tested. import { isRewrite , getRewrittenUrl } from 'next/experimental/testing/server' const request = new NextRequest ( 'https://nextjs.org/docs' ) const response = await middleware (request) expect ( isRewrite (response)) .toEqual ( true ) expect ( getRewrittenUrl (response)) .toEqual ( 'https://other-domain.com/docs' ) // getRedirectUrl could also be used if the response were a redirect Platform support Deployment Option Supported Node.js server Yes Docker container Yes Static export No Adapters Platform-specific Learn how to configure Middleware when self-hosting Next.js. Version history Version Changes v15.5.0 Middleware can now use the Node.js runtime (stable) v15.2.0 Middleware can now use the Node.js runtime (experimental) v13.1.0 Advanced Middleware flags added v13.0.0 Middleware can modify request headers, response headers, and send responses v12.2.0 Middleware is stable, please see the upgrade guide v12.0.9 Enforce absolute URLs in Edge Runtime ( PR ) v12.0.0 Middleware (Beta) added Learn more about Middleware NextRequest API Reference for NextRequest. NextResponse API Reference for NextResponse. Previous mdx-components.js Next not-found.js Was this helpful? supported. Send

---

## 10. Getting Started: Partial Prerendering | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ depend on request-time data. Dynamic Rendering With Dynamic Rendering, HTML is generated at request time . This allows you to serve personalized content based on request-time data. A component becomes dynamic if it uses the following APIs: cookies headers connection draftMode searchParams prop unstable_noStore fetch with { cache: 'no-store' } In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a Suspense boundary to wrap your component to defer rendering until runtime. Suspense React Suspense is used to defer rendering parts of your application until some condition is met. In Partial Prerendering, Suspense is used to mark dynamic boundaries in your component tree. At build time, Next.js prerenders the static content and the fallback UI. The dynamic content is postponed until the user requests the route. Wrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable streaming app/page.js import { Suspense } from 'react' import StaticComponent from './StaticComponent' import DynamicComponent from './DynamicComponent' import Fallback from './Fallback' export const experimental_ppr = true export default function Page () { return ( <> < StaticComponent /> < Suspense fallback = {< Fallback />}> < DynamicComponent /> </ Suspense > </> ) } Streaming Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. In Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel. To reduce network overhead, the full response—including static HTML and streamed dynamic parts—is sent in a single HTTP request . This avoids extra roundtrips and improves both initial load and overall performance. Enabling Partial Prerendering You can enable PPR by adding the ppr option to your next.config.ts file: next.config.ts TypeScript JavaScript TypeScript import type { NextConfig } from 'next' const nextConfig : NextConfig = { experimental : { ppr : 'incremental' , } , } export default nextConfig The 'incremental' value allows you to adopt PPR for specific routes: /app/dashboard/layout.tsx TypeScript JavaScript TypeScript export const experimental_ppr = true export default function Layout ({ children } : { children : React . ReactNode }) { // ... } Routes that don't have experimental_ppr will default to false and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route. Good to know : experimental_ppr will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route. To disable PPR for children segments, you can set experimental_ppr to false in the child segment. Examples Dynamic APIs When using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the <User /> component is dynamic because it uses the cookies API: app/user.tsx TypeScript JavaScript TypeScript import { cookies } from 'next/headers' export async function User () { const session = ( await cookies ()) .get ( 'session' )?.value return '...' } The <User /> component will be streamed while any other content inside <Page /> will be prerendered and become part of the static shell. app/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import { User , AvatarSkeleton } from './user' export const experimental_ppr = true export default function Page () { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< AvatarSkeleton />}> < User /> </ Suspense > </ section > ) } Passing dynamic props Components only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop: app/page.tsx TypeScript JavaScript TypeScript import { Table , TableSkeleton } from './table' import { Suspense } from 'react' export default function Page ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< TableSkeleton />}> < Table searchParams = {searchParams} /> </ Suspense > </ section > ) } Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be prerendered. app/table.tsx TypeScript JavaScript TypeScript export async function Table ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { const sort = ( await searchParams).sort === 'true' return '...' } Next Steps Learn more about the config option for Partial Prerendering. ppr Learn how to enable Partial Prerendering in Next.js. Previous Server and Client Components Next Fetching Data Was this helpful? supported. Send

---

## 11. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 12. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 13. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 14. Getting Started: Partial Prerendering | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ depend on request-time data. Dynamic Rendering With Dynamic Rendering, HTML is generated at request time . This allows you to serve personalized content based on request-time data. A component becomes dynamic if it uses the following APIs: cookies headers connection draftMode searchParams prop unstable_noStore fetch with { cache: 'no-store' } In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a Suspense boundary to wrap your component to defer rendering until runtime. Suspense React Suspense is used to defer rendering parts of your application until some condition is met. In Partial Prerendering, Suspense is used to mark dynamic boundaries in your component tree. At build time, Next.js prerenders the static content and the fallback UI. The dynamic content is postponed until the user requests the route. Wrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable streaming app/page.js import { Suspense } from 'react' import StaticComponent from './StaticComponent' import DynamicComponent from './DynamicComponent' import Fallback from './Fallback' export const experimental_ppr = true export default function Page () { return ( <> < StaticComponent /> < Suspense fallback = {< Fallback />}> < DynamicComponent /> </ Suspense > </> ) } Streaming Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. In Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel. To reduce network overhead, the full response—including static HTML and streamed dynamic parts—is sent in a single HTTP request . This avoids extra roundtrips and improves both initial load and overall performance. Enabling Partial Prerendering You can enable PPR by adding the ppr option to your next.config.ts file: next.config.ts TypeScript JavaScript TypeScript import type { NextConfig } from 'next' const nextConfig : NextConfig = { experimental : { ppr : 'incremental' , } , } export default nextConfig The 'incremental' value allows you to adopt PPR for specific routes: /app/dashboard/layout.tsx TypeScript JavaScript TypeScript export const experimental_ppr = true export default function Layout ({ children } : { children : React . ReactNode }) { // ... } Routes that don't have experimental_ppr will default to false and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route. Good to know : experimental_ppr will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route. To disable PPR for children segments, you can set experimental_ppr to false in the child segment. Examples Dynamic APIs When using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the <User /> component is dynamic because it uses the cookies API: app/user.tsx TypeScript JavaScript TypeScript import { cookies } from 'next/headers' export async function User () { const session = ( await cookies ()) .get ( 'session' )?.value return '...' } The <User /> component will be streamed while any other content inside <Page /> will be prerendered and become part of the static shell. app/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import { User , AvatarSkeleton } from './user' export const experimental_ppr = true export default function Page () { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< AvatarSkeleton />}> < User /> </ Suspense > </ section > ) } Passing dynamic props Components only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop: app/page.tsx TypeScript JavaScript TypeScript import { Table , TableSkeleton } from './table' import { Suspense } from 'react' export default function Page ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< TableSkeleton />}> < Table searchParams = {searchParams} /> </ Suspense > </ section > ) } Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be prerendered. app/table.tsx TypeScript JavaScript TypeScript export async function Table ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { const sort = ( await searchParams).sort === 'true' return '...' } Next Steps Learn more about the config option for Partial Prerendering. ppr Learn how to enable Partial Prerendering in Next.js. Previous Server and Client Components Next Fetching Data Was this helpful? supported. Send

---

## 15. Getting Started: Fetching Data | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://api.example.com/ artist / ${ username } 
```

```typescript
https://api.example.com/ artist / ${ username } /albums
```

### Anti-Patterns
- ❌ await the data fetching function const posts = getPosts () return ( < Suspense fallback = {< div >Loading...</ div >}> < Posts posts = {posts} /> </ Suspense > ) } Then, in your Client Component, use the use hook to read the promise: app/ui/posts.tsx TypeScript JavaScript TypeScript 'use client' import { use } from 'react' export default function Posts ({ posts , } : { posts : Promise <{ id : string ; title : string }[]> }) { const allPosts = use (posts) return ( < ul > { allPosts .map ((post) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } In the example above, the <Posts> component is wrapped in a <Suspense> boundary . This means the fallback will be shown while the promise is being resolved. Learn more about streaming . Community libraries You can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR: app/blog/page.tsx TypeScript JavaScript TypeScript 'use client' import useSWR from 'swr' const fetcher = (url) => fetch (url) .then ((r) => r .json ()) export default function BlogPage () { const { data , error , isLoading } = useSWR ( 'https://api.vercel.app/ blog ' , fetcher ) if (isLoading) return < div >Loading...</ div > if (error) return < div >Error: { error .message}</ div > return ( < ul > { data .map ((post : { id : string ; title : string }) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } Deduplicate requests and cache data One way to deduplicate fetch requests is with request memoization . With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch . Request memoization is scoped to the lifetime of a request. You can also deduplicate fetch requests by using Next.js’ Data Cache , for example by setting cache: 'force-cache' in your fetch options. Data Cache allows sharing data across the current render pass and incoming requests. If you are not using fetch , and instead using an ORM or database directly, you can wrap your data access with the React cache function. app/lib/data.ts TypeScript JavaScript TypeScript import { cache } from 'react' import { db , posts , eq } from '@/ lib /db' export const getPost = cache ( async (id : string ) => { const post = await db . query . posts .findFirst ({ where : eq ( posts .id , parseInt (id)) , }) }) Streaming Warning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary. When using async/await in Server Components, Next.js will opt into dynamic rendering . This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering. To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client. There are two ways you can implement streaming in your application: Wrapping a page with a loading.js file Wrapping a component with <Suspense> With loading.js You can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js , add the file inside the app/blog folder. app/blog/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { // Define the Loading UI here return < div >Loading...</ div > } On navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete. Behind-the-scenes, loading.js will be nested inside layout.js , and will automatically wrap the page.js file and any children below in a <Suspense> boundary. This approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense> . With <Suspense> <Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary. app/blog/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import BlogList from '@/components/BlogList' import BlogListSkeleton from '@/components/BlogListSkeleton' export default function BlogPage () { return ( < div > { /* This content will be sent to the client immediately */ } < header > < h1 >Welcome to the Blog</ h1 > < p >Read the latest posts below.</ p > </ header > < main > { /* Any content wrapped in a <Suspense> boundary will be streamed */ } < Suspense fallback = {< BlogListSkeleton />}> < BlogList /> </ Suspense > </ main > </ div > ) } Creating meaningful loading states An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. In development, you can preview and inspect the loading state of your components using the React Devtools . Examples Sequential data fetching Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated , leading to longer response times. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Get artist information const artist = await getArtist (username) return ( <> < h1 >{ artist .name}</ h1 > { /* Show fallback UI while the Playlists component is loading */ } < Suspense fallback = {< div >Loading...</ div >}> { /* Pass the artist ID to the Playlists component */ } < Playlists artist ID = { artist .id} /> </ Suspense > </> ) } async function Playlists ({ artist ID } : { artist ID : string }) { // Use the artist ID to fetch playlists const playlists = await getArtistPlaylists ( artist ID) return ( < ul > { playlists .map ((playlist) => ( < li key = { playlist .id}>{ playlist .name}</ li > ))} </ ul > ) } To improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests. Parallel data fetching Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time. By default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible. However, within any component, multiple async / await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import { getArtist , getAlbums } from '@/app/lib/data' export default async function Page ({ params }) { // These requests will be sequential const { username } = await params const artist = await getArtist (username) const albums = await getAlbums (username) return < div >{ artist .name}</ div > } Start multiple requests by calling fetch , then await them with Promise.all . Requests begin as soon as fetch is called. app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import Albums from './albums' async function getArtist (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } ` ) return res .json () } async function getAlbums (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } /albums` ) return res .json () } export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Initiate requests const artist Data = getArtist (username) const albumsData = getAlbums (username) const [ artist , albums ] = await Promise .all ([ artist Data , albumsData]) return ( <> < h1 >{ artist .name}</ h1 > < Albums list = {albums} /> </> ) } Good to know: If one request fails when using Promise.all , the entire operation will fail. To handle this, you can use the Promise.allSettled method instead. Preloading data You can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function. You can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched. app/item/[id]/page.tsx TypeScript JavaScript TypeScript import { getItem , checkIsAvailable } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params // starting loading item data preload (id) // perform another asynchronous task const isAvailable = await checkIsAvailable () return isAvailable ? < Item id = {id} /> : null } export const preload = (id : string ) => { // void evaluates the given expression and returns undefined // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void void getItem (id) } export async function Item ({ id } : { id : string }) { const result = await getItem (id) // ... } Additionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server. utils/get-item.ts TypeScript JavaScript TypeScript import { cache } from 'react' import 'server-only' import { getItem } from '@/lib/data' export const preload = (id : string ) => { void getItem (id) } export const getItem = cache ( async (id : string ) => { // ... }) API Reference Learn more about the features mentioned in this page by reading the API Reference. Data Security Learn the built-in data security features in Next.js and learn best practices for protecting your application's data. fetch API reference for the extended fetch function. loading.js API reference for the loading.js file. logging Configure how data fetches are logged to the console when running Next.js in development mode. taint Enable tainting Objects and Values. Previous Partial Prerendering Next Updating Data Was this helpful? supported. Send

---

## 16. Getting Started: Fetching Data | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://api.example.com/ artist / ${ username } 
```

```typescript
https://api.example.com/ artist / ${ username } /albums
```

### Anti-Patterns
- ❌ await the data fetching function const posts = getPosts () return ( < Suspense fallback = {< div >Loading...</ div >}> < Posts posts = {posts} /> </ Suspense > ) } Then, in your Client Component, use the use hook to read the promise: app/ui/posts.tsx TypeScript JavaScript TypeScript 'use client' import { use } from 'react' export default function Posts ({ posts , } : { posts : Promise <{ id : string ; title : string }[]> }) { const allPosts = use (posts) return ( < ul > { allPosts .map ((post) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } In the example above, the <Posts> component is wrapped in a <Suspense> boundary . This means the fallback will be shown while the promise is being resolved. Learn more about streaming . Community libraries You can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR: app/blog/page.tsx TypeScript JavaScript TypeScript 'use client' import useSWR from 'swr' const fetcher = (url) => fetch (url) .then ((r) => r .json ()) export default function BlogPage () { const { data , error , isLoading } = useSWR ( 'https://api.vercel.app/ blog ' , fetcher ) if (isLoading) return < div >Loading...</ div > if (error) return < div >Error: { error .message}</ div > return ( < ul > { data .map ((post : { id : string ; title : string }) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } Deduplicate requests and cache data One way to deduplicate fetch requests is with request memoization . With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch . Request memoization is scoped to the lifetime of a request. You can also deduplicate fetch requests by using Next.js’ Data Cache , for example by setting cache: 'force-cache' in your fetch options. Data Cache allows sharing data across the current render pass and incoming requests. If you are not using fetch , and instead using an ORM or database directly, you can wrap your data access with the React cache function. app/lib/data.ts TypeScript JavaScript TypeScript import { cache } from 'react' import { db , posts , eq } from '@/ lib /db' export const getPost = cache ( async (id : string ) => { const post = await db . query . posts .findFirst ({ where : eq ( posts .id , parseInt (id)) , }) }) Streaming Warning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary. When using async/await in Server Components, Next.js will opt into dynamic rendering . This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering. To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client. There are two ways you can implement streaming in your application: Wrapping a page with a loading.js file Wrapping a component with <Suspense> With loading.js You can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js , add the file inside the app/blog folder. app/blog/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { // Define the Loading UI here return < div >Loading...</ div > } On navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete. Behind-the-scenes, loading.js will be nested inside layout.js , and will automatically wrap the page.js file and any children below in a <Suspense> boundary. This approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense> . With <Suspense> <Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary. app/blog/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import BlogList from '@/components/BlogList' import BlogListSkeleton from '@/components/BlogListSkeleton' export default function BlogPage () { return ( < div > { /* This content will be sent to the client immediately */ } < header > < h1 >Welcome to the Blog</ h1 > < p >Read the latest posts below.</ p > </ header > < main > { /* Any content wrapped in a <Suspense> boundary will be streamed */ } < Suspense fallback = {< BlogListSkeleton />}> < BlogList /> </ Suspense > </ main > </ div > ) } Creating meaningful loading states An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. In development, you can preview and inspect the loading state of your components using the React Devtools . Examples Sequential data fetching Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated , leading to longer response times. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Get artist information const artist = await getArtist (username) return ( <> < h1 >{ artist .name}</ h1 > { /* Show fallback UI while the Playlists component is loading */ } < Suspense fallback = {< div >Loading...</ div >}> { /* Pass the artist ID to the Playlists component */ } < Playlists artist ID = { artist .id} /> </ Suspense > </> ) } async function Playlists ({ artist ID } : { artist ID : string }) { // Use the artist ID to fetch playlists const playlists = await getArtistPlaylists ( artist ID) return ( < ul > { playlists .map ((playlist) => ( < li key = { playlist .id}>{ playlist .name}</ li > ))} </ ul > ) } To improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests. Parallel data fetching Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time. By default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible. However, within any component, multiple async / await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import { getArtist , getAlbums } from '@/app/lib/data' export default async function Page ({ params }) { // These requests will be sequential const { username } = await params const artist = await getArtist (username) const albums = await getAlbums (username) return < div >{ artist .name}</ div > } Start multiple requests by calling fetch , then await them with Promise.all . Requests begin as soon as fetch is called. app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import Albums from './albums' async function getArtist (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } ` ) return res .json () } async function getAlbums (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } /albums` ) return res .json () } export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Initiate requests const artist Data = getArtist (username) const albumsData = getAlbums (username) const [ artist , albums ] = await Promise .all ([ artist Data , albumsData]) return ( <> < h1 >{ artist .name}</ h1 > < Albums list = {albums} /> </> ) } Good to know: If one request fails when using Promise.all , the entire operation will fail. To handle this, you can use the Promise.allSettled method instead. Preloading data You can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function. You can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched. app/item/[id]/page.tsx TypeScript JavaScript TypeScript import { getItem , checkIsAvailable } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params // starting loading item data preload (id) // perform another asynchronous task const isAvailable = await checkIsAvailable () return isAvailable ? < Item id = {id} /> : null } export const preload = (id : string ) => { // void evaluates the given expression and returns undefined // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void void getItem (id) } export async function Item ({ id } : { id : string }) { const result = await getItem (id) // ... } Additionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server. utils/get-item.ts TypeScript JavaScript TypeScript import { cache } from 'react' import 'server-only' import { getItem } from '@/lib/data' export const preload = (id : string ) => { void getItem (id) } export const getItem = cache ( async (id : string ) => { // ... }) API Reference Learn more about the features mentioned in this page by reading the API Reference. Data Security Learn the built-in data security features in Next.js and learn best practices for protecting your application's data. fetch API reference for the extended fetch function. loading.js API reference for the loading.js file. logging Configure how data fetches are logged to the console when running Next.js in development mode. taint Enable tainting Objects and Values. Previous Partial Prerendering Next Updating Data Was this helpful? supported. Send

---

## 17. Getting Started: Caching and Revalidating | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://...
```

---

## 18. Getting Started: Caching and Revalidating | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://...
```

---

## 19. Guides: Forms | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 20. Getting Started: CSS | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ duplicate imports. Turn off linters or formatters that auto-sort imports like ESLint’s sort-imports . You can use the cssChunking option in next.config.js to control how CSS is chunked. Development vs Production In development ( next dev ), CSS updates apply instantly with Fast Refresh . In production ( next build ), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route. CSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh. CSS ordering can behave differently in development, always ensure to check the build ( next build ) to verify the final CSS order. Next Steps Learn more about the alternatives ways you can use CSS in your application. Tailwind CSS v3 Style your Next.js Application using Tailwind CSS v3 for broader browser support. Sass Style your Next.js application using Sass. CSS-in-JS Use CSS-in-JS libraries with Next.js Previous Error Handling Next Image Optimization Was this helpful? supported. Send

---

## 21. Getting Started: CSS | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ duplicate imports. Turn off linters or formatters that auto-sort imports like ESLint’s sort-imports . You can use the cssChunking option in next.config.js to control how CSS is chunked. Development vs Production In development ( next dev ), CSS updates apply instantly with Fast Refresh . In production ( next build ), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route. CSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh. CSS ordering can behave differently in development, always ensure to check the build ( next build ) to verify the final CSS order. Next Steps Learn more about the alternatives ways you can use CSS in your application. Tailwind CSS v3 Style your Next.js Application using Tailwind CSS v3 for broader browser support. Sass Style your Next.js application using Sass. CSS-in-JS Use CSS-in-JS libraries with Next.js Previous Error Handling Next Image Optimization Was this helpful? supported. Send

---

## 22. Getting Started: CSS | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ duplicate imports. Turn off linters or formatters that auto-sort imports like ESLint’s sort-imports . You can use the cssChunking option in next.config.js to control how CSS is chunked. Development vs Production In development ( next dev ), CSS updates apply instantly with Fast Refresh . In production ( next build ), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route. CSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh. CSS ordering can behave differently in development, always ensure to check the build ( next build ) to verify the final CSS order. Next Steps Learn more about the alternatives ways you can use CSS in your application. Tailwind CSS v3 Style your Next.js Application using Tailwind CSS v3 for broader browser support. Sass Style your Next.js application using Sass. CSS-in-JS Use CSS-in-JS libraries with Next.js Previous Error Handling Next Image Optimization Was this helpful? supported. Send

---

## 23. Guides: Sass | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 24. Guides: CSS-in-JS | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 25. App Router: Getting Started | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
create-next-app
```

---

## 26. Getting Started: Image Optimization | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ layout shift from the image loading in. Alternatively, you can use the fill property to make the image fill the size of the parent element. To safely allow images from remote servers, you need to define a list of supported URL patterns in next.config.js . Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket: next.config.ts TypeScript JavaScript TypeScript import type { NextConfig } from 'next' const config : NextConfig = { images : { remotePatterns : [ { protocol : 'https' , hostname : 's3.amazonaws.com' , port : '' , pathname : '/my-bucket/**' , search : '' , } , ] , } , } export default config API Reference See the API Reference for the full feature set of Next.js Image. Image Component Optimize Images in your Next.js Application using the built-in `next/image` Component. Previous CSS Next Font Optimization Was this helpful? supported. Send

---

## 27. Getting Started: Font Optimization | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 28. File-system conventions: public | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
/avatars/ ${ id } .png
```

---

## 29. Guides: Lazy Loading | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 30. Configuration: next.config.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
allowedDevOrigins
```

```typescript
authInterrupts
```

```typescript
unauthorized
```

```typescript
crossOrigin
```

```typescript
next/script
```

### Anti-Patterns
- ❌ using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstable_getResponseFromNextConfig function runs the headers , redirects , and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test. import { getRedirectUrl , unstable_getResponseFromNextConfig , } from 'next/experimental/testing/server' const response = await unstable_getResponseFromNextConfig ({ url : 'https://nextjs.org/test' , nextConfig : { async redirects () { return [{ source : '/test' , destination : '/test2' , permanent : false }] } , } , }) expect ( response .status) .toEqual ( 307 ) expect ( getRedirectUrl (response)) .toEqual ( 'https://nextjs.org/test2' ) allowedDevOrigins Use `allowedDevOrigins` to configure additional origins that can request the dev server. appDir Enable the App Router to use layouts, streaming, and more. assetPrefix Learn how to use the assetPrefix config option to configure your CDN. authInterrupts Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`. basePath Use `basePath` to deploy a Next.js application under a sub-path of a domain. browserDebugInfoInTerminal Forward browser console logs and errors to your terminal during development. cacheComponents Learn how to enable the cacheComponents flag in Next.js. cacheLife Learn how to set up cacheLife configurations in Next.js. compress Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. crossOrigin Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`. cssChunking Use the `cssChunking` option to control how CSS files are chunked in your Next.js application. devIndicators Configuration options for the on-screen indicator that gives context about the current route you're viewing during development. distDir Set a custom build directory to use instead of the default .next directory. env Learn to add and access environment variables in your Next.js application at build time. eslint Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. expireTime Customize stale-while-revalidate expire time for ISR enabled pages. exportPathMap Customize the pages that will be exported as HTML files when using `next export`. generateBuildId Configure the build id, which is used to identify the current build in which your application is being served. generateEtags Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. headers Add custom HTTP headers to your Next.js app. htmlLimitedBots Specify a list of user agents that should receive blocking metadata. httpAgentOptions Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. images Custom configuration for the next/image loader cacheHandler Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others. inlineCss Enable inline CSS support. logging Configure how data fetches are logged to the console when running Next.js in development mode. mdxRs Use the new Rust compiler to compile MDX files in the App Router. onDemandEntries Configure how Next.js will dispose and keep in memory pages created in development. optimizePackageImports API Reference for optimizePackageImports Next.js Config Option output Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here. pageExtensions Extend the default page extensions used by Next.js when resolving pages in the Pages Router. poweredByHeader Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. ppr Learn how to enable Partial Prerendering in Next.js. productionBrowserSourceMaps Enables browser source map generation during the production build. reactCompiler Enable the React Compiler to automatically optimize component rendering. reactMaxHeadersLength The maximum length of the headers that are emitted by React and added to the response. reactStrictMode The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in redirects Add redirects to your Next.js app. rewrites Add rewrites to your Next.js app. sassOptions Configure Sass options. serverActions Configure Server Actions behavior in your Next.js application. serverComponentsHmrCache Configure whether fetch responses in Server Components are cached across HMR refresh requests. serverExternalPackages Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. staleTimes Learn how to override the invalidation time of the Client Router Cache. staticGeneration* Learn how to configure static generation in your Next.js application. taint Enable tainting Objects and Values. trailingSlash Configure Next.js pages to resolve with or without a trailing slash. transpilePackages Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). turbopack Configure Next.js with Turbopack-specific options turbopackPersistentCaching Learn how to enable Persistent Caching for Turbopack builds typedRoutes Enable support for statically typed links. typescript Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. urlImports Configure Next.js to allow importing modules from external URLs. useCache Learn how to enable the useCache flag in Next.js. useLightningcss Enable experimental support for Lightning CSS. viewTransition Enable ViewTransition API from React in App Router webpack Learn how to customize the webpack config used by Next.js webVitalsAttribution Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. Previous Configuration Next allowedDevOrigins Was this helpful? supported. Send

---

## 31. Configuration: next.config.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
allowedDevOrigins
```

```typescript
authInterrupts
```

```typescript
unauthorized
```

```typescript
crossOrigin
```

```typescript
next/script
```

### Anti-Patterns
- ❌ using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstable_getResponseFromNextConfig function runs the headers , redirects , and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test. import { getRedirectUrl , unstable_getResponseFromNextConfig , } from 'next/experimental/testing/server' const response = await unstable_getResponseFromNextConfig ({ url : 'https://nextjs.org/test' , nextConfig : { async redirects () { return [{ source : '/test' , destination : '/test2' , permanent : false }] } , } , }) expect ( response .status) .toEqual ( 307 ) expect ( getRedirectUrl (response)) .toEqual ( 'https://nextjs.org/test2' ) allowedDevOrigins Use `allowedDevOrigins` to configure additional origins that can request the dev server. appDir Enable the App Router to use layouts, streaming, and more. assetPrefix Learn how to use the assetPrefix config option to configure your CDN. authInterrupts Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`. basePath Use `basePath` to deploy a Next.js application under a sub-path of a domain. browserDebugInfoInTerminal Forward browser console logs and errors to your terminal during development. cacheComponents Learn how to enable the cacheComponents flag in Next.js. cacheLife Learn how to set up cacheLife configurations in Next.js. compress Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. crossOrigin Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`. cssChunking Use the `cssChunking` option to control how CSS files are chunked in your Next.js application. devIndicators Configuration options for the on-screen indicator that gives context about the current route you're viewing during development. distDir Set a custom build directory to use instead of the default .next directory. env Learn to add and access environment variables in your Next.js application at build time. eslint Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. expireTime Customize stale-while-revalidate expire time for ISR enabled pages. exportPathMap Customize the pages that will be exported as HTML files when using `next export`. generateBuildId Configure the build id, which is used to identify the current build in which your application is being served. generateEtags Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. headers Add custom HTTP headers to your Next.js app. htmlLimitedBots Specify a list of user agents that should receive blocking metadata. httpAgentOptions Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. images Custom configuration for the next/image loader cacheHandler Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others. inlineCss Enable inline CSS support. logging Configure how data fetches are logged to the console when running Next.js in development mode. mdxRs Use the new Rust compiler to compile MDX files in the App Router. onDemandEntries Configure how Next.js will dispose and keep in memory pages created in development. optimizePackageImports API Reference for optimizePackageImports Next.js Config Option output Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here. pageExtensions Extend the default page extensions used by Next.js when resolving pages in the Pages Router. poweredByHeader Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. ppr Learn how to enable Partial Prerendering in Next.js. productionBrowserSourceMaps Enables browser source map generation during the production build. reactCompiler Enable the React Compiler to automatically optimize component rendering. reactMaxHeadersLength The maximum length of the headers that are emitted by React and added to the response. reactStrictMode The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in redirects Add redirects to your Next.js app. rewrites Add rewrites to your Next.js app. sassOptions Configure Sass options. serverActions Configure Server Actions behavior in your Next.js application. serverComponentsHmrCache Configure whether fetch responses in Server Components are cached across HMR refresh requests. serverExternalPackages Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. staleTimes Learn how to override the invalidation time of the Client Router Cache. staticGeneration* Learn how to configure static generation in your Next.js application. taint Enable tainting Objects and Values. trailingSlash Configure Next.js pages to resolve with or without a trailing slash. transpilePackages Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). turbopack Configure Next.js with Turbopack-specific options turbopackPersistentCaching Learn how to enable Persistent Caching for Turbopack builds typedRoutes Enable support for statically typed links. typescript Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. urlImports Configure Next.js to allow importing modules from external URLs. useCache Learn how to enable the useCache flag in Next.js. useLightningcss Enable experimental support for Lightning CSS. viewTransition Enable ViewTransition API from React in App Router webpack Learn how to customize the webpack config used by Next.js webVitalsAttribution Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. Previous Configuration Next allowedDevOrigins Was this helpful? supported. Send

---

## 32. Configuration: next.config.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
allowedDevOrigins
```

```typescript
authInterrupts
```

```typescript
unauthorized
```

```typescript
crossOrigin
```

```typescript
next/script
```

### Anti-Patterns
- ❌ using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstable_getResponseFromNextConfig function runs the headers , redirects , and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test. import { getRedirectUrl , unstable_getResponseFromNextConfig , } from 'next/experimental/testing/server' const response = await unstable_getResponseFromNextConfig ({ url : 'https://nextjs.org/test' , nextConfig : { async redirects () { return [{ source : '/test' , destination : '/test2' , permanent : false }] } , } , }) expect ( response .status) .toEqual ( 307 ) expect ( getRedirectUrl (response)) .toEqual ( 'https://nextjs.org/test2' ) allowedDevOrigins Use `allowedDevOrigins` to configure additional origins that can request the dev server. appDir Enable the App Router to use layouts, streaming, and more. assetPrefix Learn how to use the assetPrefix config option to configure your CDN. authInterrupts Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`. basePath Use `basePath` to deploy a Next.js application under a sub-path of a domain. browserDebugInfoInTerminal Forward browser console logs and errors to your terminal during development. cacheComponents Learn how to enable the cacheComponents flag in Next.js. cacheLife Learn how to set up cacheLife configurations in Next.js. compress Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. crossOrigin Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`. cssChunking Use the `cssChunking` option to control how CSS files are chunked in your Next.js application. devIndicators Configuration options for the on-screen indicator that gives context about the current route you're viewing during development. distDir Set a custom build directory to use instead of the default .next directory. env Learn to add and access environment variables in your Next.js application at build time. eslint Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. expireTime Customize stale-while-revalidate expire time for ISR enabled pages. exportPathMap Customize the pages that will be exported as HTML files when using `next export`. generateBuildId Configure the build id, which is used to identify the current build in which your application is being served. generateEtags Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. headers Add custom HTTP headers to your Next.js app. htmlLimitedBots Specify a list of user agents that should receive blocking metadata. httpAgentOptions Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. images Custom configuration for the next/image loader cacheHandler Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others. inlineCss Enable inline CSS support. logging Configure how data fetches are logged to the console when running Next.js in development mode. mdxRs Use the new Rust compiler to compile MDX files in the App Router. onDemandEntries Configure how Next.js will dispose and keep in memory pages created in development. optimizePackageImports API Reference for optimizePackageImports Next.js Config Option output Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here. pageExtensions Extend the default page extensions used by Next.js when resolving pages in the Pages Router. poweredByHeader Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. ppr Learn how to enable Partial Prerendering in Next.js. productionBrowserSourceMaps Enables browser source map generation during the production build. reactCompiler Enable the React Compiler to automatically optimize component rendering. reactMaxHeadersLength The maximum length of the headers that are emitted by React and added to the response. reactStrictMode The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in redirects Add redirects to your Next.js app. rewrites Add rewrites to your Next.js app. sassOptions Configure Sass options. serverActions Configure Server Actions behavior in your Next.js application. serverComponentsHmrCache Configure whether fetch responses in Server Components are cached across HMR refresh requests. serverExternalPackages Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. staleTimes Learn how to override the invalidation time of the Client Router Cache. staticGeneration* Learn how to configure static generation in your Next.js application. taint Enable tainting Objects and Values. trailingSlash Configure Next.js pages to resolve with or without a trailing slash. transpilePackages Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). turbopack Configure Next.js with Turbopack-specific options turbopackPersistentCaching Learn how to enable Persistent Caching for Turbopack builds typedRoutes Enable support for statically typed links. typescript Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. urlImports Configure Next.js to allow importing modules from external URLs. useCache Learn how to enable the useCache flag in Next.js. useLightningcss Enable experimental support for Lightning CSS. viewTransition Enable ViewTransition API from React in App Router webpack Learn how to customize the webpack config used by Next.js webVitalsAttribution Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. Previous Configuration Next allowedDevOrigins Was this helpful? supported. Send

---

## 33. Configuration: next.config.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
allowedDevOrigins
```

```typescript
authInterrupts
```

```typescript
unauthorized
```

```typescript
crossOrigin
```

```typescript
next/script
```

### Anti-Patterns
- ❌ using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstable_getResponseFromNextConfig function runs the headers , redirects , and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test. import { getRedirectUrl , unstable_getResponseFromNextConfig , } from 'next/experimental/testing/server' const response = await unstable_getResponseFromNextConfig ({ url : 'https://nextjs.org/test' , nextConfig : { async redirects () { return [{ source : '/test' , destination : '/test2' , permanent : false }] } , } , }) expect ( response .status) .toEqual ( 307 ) expect ( getRedirectUrl (response)) .toEqual ( 'https://nextjs.org/test2' ) allowedDevOrigins Use `allowedDevOrigins` to configure additional origins that can request the dev server. appDir Enable the App Router to use layouts, streaming, and more. assetPrefix Learn how to use the assetPrefix config option to configure your CDN. authInterrupts Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`. basePath Use `basePath` to deploy a Next.js application under a sub-path of a domain. browserDebugInfoInTerminal Forward browser console logs and errors to your terminal during development. cacheComponents Learn how to enable the cacheComponents flag in Next.js. cacheLife Learn how to set up cacheLife configurations in Next.js. compress Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. crossOrigin Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`. cssChunking Use the `cssChunking` option to control how CSS files are chunked in your Next.js application. devIndicators Configuration options for the on-screen indicator that gives context about the current route you're viewing during development. distDir Set a custom build directory to use instead of the default .next directory. env Learn to add and access environment variables in your Next.js application at build time. eslint Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. expireTime Customize stale-while-revalidate expire time for ISR enabled pages. exportPathMap Customize the pages that will be exported as HTML files when using `next export`. generateBuildId Configure the build id, which is used to identify the current build in which your application is being served. generateEtags Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. headers Add custom HTTP headers to your Next.js app. htmlLimitedBots Specify a list of user agents that should receive blocking metadata. httpAgentOptions Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. images Custom configuration for the next/image loader cacheHandler Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others. inlineCss Enable inline CSS support. logging Configure how data fetches are logged to the console when running Next.js in development mode. mdxRs Use the new Rust compiler to compile MDX files in the App Router. onDemandEntries Configure how Next.js will dispose and keep in memory pages created in development. optimizePackageImports API Reference for optimizePackageImports Next.js Config Option output Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here. pageExtensions Extend the default page extensions used by Next.js when resolving pages in the Pages Router. poweredByHeader Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. ppr Learn how to enable Partial Prerendering in Next.js. productionBrowserSourceMaps Enables browser source map generation during the production build. reactCompiler Enable the React Compiler to automatically optimize component rendering. reactMaxHeadersLength The maximum length of the headers that are emitted by React and added to the response. reactStrictMode The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in redirects Add redirects to your Next.js app. rewrites Add rewrites to your Next.js app. sassOptions Configure Sass options. serverActions Configure Server Actions behavior in your Next.js application. serverComponentsHmrCache Configure whether fetch responses in Server Components are cached across HMR refresh requests. serverExternalPackages Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. staleTimes Learn how to override the invalidation time of the Client Router Cache. staticGeneration* Learn how to configure static generation in your Next.js application. taint Enable tainting Objects and Values. trailingSlash Configure Next.js pages to resolve with or without a trailing slash. transpilePackages Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). turbopack Configure Next.js with Turbopack-specific options turbopackPersistentCaching Learn how to enable Persistent Caching for Turbopack builds typedRoutes Enable support for statically typed links. typescript Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. urlImports Configure Next.js to allow importing modules from external URLs. useCache Learn how to enable the useCache flag in Next.js. useLightningcss Enable experimental support for Lightning CSS. viewTransition Enable ViewTransition API from React in App Router webpack Learn how to customize the webpack config used by Next.js webVitalsAttribution Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. Previous Configuration Next allowedDevOrigins Was this helpful? supported. Send

---

## 34. App Router: API Reference | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 35. API Reference: Functions | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 36. API Reference: Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
next/script
```

---

## 37. API Reference: File-system conventions | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 38. Configuration: next.config.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
allowedDevOrigins
```

```typescript
authInterrupts
```

```typescript
unauthorized
```

```typescript
crossOrigin
```

```typescript
next/script
```

### Anti-Patterns
- ❌ using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel. This page documents all the available configuration options: Unit Testing (experimental) Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files. The unstable_getResponseFromNextConfig function runs the headers , redirects , and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing. The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test. import { getRedirectUrl , unstable_getResponseFromNextConfig , } from 'next/experimental/testing/server' const response = await unstable_getResponseFromNextConfig ({ url : 'https://nextjs.org/test' , nextConfig : { async redirects () { return [{ source : '/test' , destination : '/test2' , permanent : false }] } , } , }) expect ( response .status) .toEqual ( 307 ) expect ( getRedirectUrl (response)) .toEqual ( 'https://nextjs.org/test2' ) allowedDevOrigins Use `allowedDevOrigins` to configure additional origins that can request the dev server. appDir Enable the App Router to use layouts, streaming, and more. assetPrefix Learn how to use the assetPrefix config option to configure your CDN. authInterrupts Learn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`. basePath Use `basePath` to deploy a Next.js application under a sub-path of a domain. browserDebugInfoInTerminal Forward browser console logs and errors to your terminal during development. cacheComponents Learn how to enable the cacheComponents flag in Next.js. cacheLife Learn how to set up cacheLife configurations in Next.js. compress Next.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here. crossOrigin Use the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`. cssChunking Use the `cssChunking` option to control how CSS files are chunked in your Next.js application. devIndicators Configuration options for the on-screen indicator that gives context about the current route you're viewing during development. distDir Set a custom build directory to use instead of the default .next directory. env Learn to add and access environment variables in your Next.js application at build time. eslint Next.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here. expireTime Customize stale-while-revalidate expire time for ISR enabled pages. exportPathMap Customize the pages that will be exported as HTML files when using `next export`. generateBuildId Configure the build id, which is used to identify the current build in which your application is being served. generateEtags Next.js will generate etags for every page by default. Learn more about how to disable etag generation here. headers Add custom HTTP headers to your Next.js app. htmlLimitedBots Specify a list of user agents that should receive blocking metadata. httpAgentOptions Next.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here. images Custom configuration for the next/image loader cacheHandler Configure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others. inlineCss Enable inline CSS support. logging Configure how data fetches are logged to the console when running Next.js in development mode. mdxRs Use the new Rust compiler to compile MDX files in the App Router. onDemandEntries Configure how Next.js will dispose and keep in memory pages created in development. optimizePackageImports API Reference for optimizePackageImports Next.js Config Option output Next.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here. pageExtensions Extend the default page extensions used by Next.js when resolving pages in the Pages Router. poweredByHeader Next.js will add the `x-powered-by` header by default. Learn to opt-out of it here. ppr Learn how to enable Partial Prerendering in Next.js. productionBrowserSourceMaps Enables browser source map generation during the production build. reactCompiler Enable the React Compiler to automatically optimize component rendering. reactMaxHeadersLength The maximum length of the headers that are emitted by React and added to the response. reactStrictMode The complete Next.js runtime is now Strict Mode-compliant, learn how to opt-in redirects Add redirects to your Next.js app. rewrites Add rewrites to your Next.js app. sassOptions Configure Sass options. serverActions Configure Server Actions behavior in your Next.js application. serverComponentsHmrCache Configure whether fetch responses in Server Components are cached across HMR refresh requests. serverExternalPackages Opt-out specific dependencies from the Server Components bundling and use native Node.js `require`. staleTimes Learn how to override the invalidation time of the Client Router Cache. staticGeneration* Learn how to configure static generation in your Next.js application. taint Enable tainting Objects and Values. trailingSlash Configure Next.js pages to resolve with or without a trailing slash. transpilePackages Automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`). turbopack Configure Next.js with Turbopack-specific options turbopackPersistentCaching Learn how to enable Persistent Caching for Turbopack builds typedRoutes Enable support for statically typed links. typescript Next.js reports TypeScript errors by default. Learn to opt-out of this behavior here. urlImports Configure Next.js to allow importing modules from external URLs. useCache Learn how to enable the useCache flag in Next.js. useLightningcss Enable experimental support for Lightning CSS. viewTransition Enable ViewTransition API from React in App Router webpack Learn how to customize the webpack config used by Next.js webVitalsAttribution Learn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues. Previous Configuration Next allowedDevOrigins Was this helpful? supported. Send

---

## 39. Guides: Authentication | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
/api/user/ ${ userId } 
```

### Anti-Patterns
- ❌ re-render on navigation, meaning the user session won't be checked on every route change. Instead, you should do the checks close to your data source or the component that'll be conditionally rendered. For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data ( getUser() ) in the layout and do the auth check in your DAL. This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data. app/layout.tsx TypeScript JavaScript TypeScript export default async function Layout ({ children , } : { children : React . ReactNode ; }) { const user = await getUser (); return ( // ... ) } app/lib/dal.ts TypeScript JavaScript TypeScript export const getUser = cache ( async () => { const session = await verifySession () if ( ! session) return null // Get user ID from session and fetch data }) Good to know: A common pattern in SPAs is to return null in a layout or a top-level component if a user is not authorized. This pattern is not recommended since Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed. Server Actions Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation. In the example below, we check the user's role before allowing the action to proceed: app/lib/actions.ts TypeScript JavaScript TypeScript 'use server' import { verifySession } from '@/app/ lib /dal' export async function serverAction (formData : FormData ) { const session = await verifySession () const userRole = session ?. user ?.role // Return early if user is not authorized to perform the action if (userRole !== 'admin' ) { return null } // Proceed with the action for authorized users } Route Handlers Treat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler. For example: app/api/route.ts TypeScript JavaScript TypeScript import { verifySession } from '@/app/lib/dal' export async function GET () { // User authentication and role verification const session = await verifySession () // Check if the user is authenticated if ( ! session) { // User is not authenticated return new Response ( null , { status : 401 }) } // Check if the user has the 'admin' role if ( session . user .role !== 'admin' ) { // User is authenticated but does not have the right permissions return new Response ( null , { status : 403 }) } // Continue for authorized users } The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. Context Providers Using context providers for auth works due to interleaving . However, React context is not supported in Server Components, making them only applicable to Client Components. This works, but any child Server Components will be rendered on the server first, and will not have access to the context provider’s session data: app/layout.ts TypeScript JavaScript TypeScript import { ContextProvider } from 'auth-lib' export default function RootLayout ({ children }) { return ( < html lang = "en" > < body > < ContextProvider >{children}</ ContextProvider > </ body > </ html > ) } 'use client' ; import { useSession } from "auth-lib" ; export default function Profile () { const { userId } = useSession (); const { data } = useSWR ( `/api/user/ ${ userId } ` , fetcher) return ( // ... ); } If session data is needed in Client Components (e.g. for client-side data fetching), use React’s taintUniqueValue API to prevent sensitive session data from being exposed to the client. Resources Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management: Auth Libraries Auth0 Better Auth Clerk Kinde Logto NextAuth.js Ory Stack Auth Supabase Stytch WorkOS Session Management Libraries Iron Session Jose Further Reading To continue learning about authentication and security, check out the following resources: How to think about security in Next.js Understanding XSS Attacks Understanding CSRF Attacks The Copenhagen Book Previous Analytics Next Backend for Frontend Was this helpful? supported. Send
- ❌ database checks to prevent performance issues. For example: middleware.ts TypeScript JavaScript TypeScript import { NextRequest , NextResponse } from 'next/server' import { decrypt } from '@/app/lib/session' import { cookies } from 'next/headers' // 1. Specify protected and public routes const protectedRoutes = [ '/dashboard' ] const publicRoutes = [ '/login' , '/signup' , '/' ] export default async function middleware (req : NextRequest ) { // 2. Check if the current route is protected or public const path = req . nextUrl .pathname const isProtectedRoute = protectedRoutes .includes (path) const isPublicRoute = publicRoutes .includes (path) // 3. Decrypt the session from the cookie const cookie = ( await cookies ()) .get ( 'session' )?.value const session = await decrypt (cookie) // 4. Redirect to /login if the user is not authenticated if (isProtectedRoute && ! session ?.userId) { return NextResponse .redirect ( new URL ( '/login' , req .nextUrl)) } // 5. Redirect to /dashboard if the user is authenticated if ( isPublicRoute && session ?.userId && ! req . nextUrl . pathname .startsWith ( '/dashboard' ) ) { return NextResponse .redirect ( new URL ( '/dashboard' , req .nextUrl)) } return NextResponse .next () } // Routes Middleware should not run on export const config = { matcher : [ '/((?!api|_next/static|_next/image|.*\\.png$).*)' ] , } While Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information. Tips : In Middleware, you can also read cookies using req.cookies.get('session').value . Middleware uses the Edge Runtime , check if your Auth library and session management library are compatible. You can use the matcher property in the Middleware to specify which routes Middleware should run on. Although, for auth, it's recommended Middleware runs on all routes. Creating a Data Access Layer (DAL) We recommend creating a DAL to centralize your data requests and authorization logic. The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests. For example, create a separate file for your DAL that includes a verifySession() function. Then use React's cache API to memoize the return value of the function during a React render pass: app/lib/dal.ts TypeScript JavaScript TypeScript import 'server-only' import { cookies } from 'next/headers' import { decrypt } from '@/app/ lib /session' export const verifySession = cache ( async () => { const cookie = ( await cookies ()) .get ( 'session' )?.value const session = await decrypt (cookie) if ( ! session ?.userId) { redirect ( '/login' ) } return { isAuth : true , userId : session .userId } }) You can then invoke the verifySession() function in your data requests, Server Actions, Route Handlers: app/lib/dal.ts TypeScript JavaScript TypeScript export const getUser = cache ( async () => { const session = await verifySession () if ( ! session) return null try { const data = await db . query . users .findMany ({ where : eq ( users .id , session .userId) , // Explicitly return the columns you need rather than the whole user object columns : { id : true , name : true , email : true , } , }) const user = data[ 0 ] return user } catch (error) { console .log ( 'Failed to fetch user' ) return null } }) Tip : A DAL can be used to protect data fetched at request time. However, for static routes that share data between users, data will be fetched at build time and not at request time. Use Middleware to protect static routes. For secure checks, you can check if the session is valid by comparing the session ID with your database. Use React's cache function to avoid unnecessary duplicate requests to the database during a render pass. You may wish to consolidate related data requests in a JavaScript class that runs verifySession() before any methods. Using Data Transfer Objects (DTO) When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc. However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client. app/lib/dto.ts TypeScript JavaScript TypeScript import 'server-only' import { getUser } from '@/app/ lib /dal' function canSeeUsername (viewer : User ) { return true } function canSeePhoneNumber (viewer : User , team : string ) { return viewer .isAdmin || team === viewer .team } export async function getProfileDTO (slug : string ) { const data = await db . query . users .findMany ({ where : eq ( users .slug , slug) , // Return specific columns here }) const user = data[ 0 ] const currentUser = await getUser ( user .id) // Or return only what's specific to the query here return { username : canSeeUsername (currentUser) ? user .username : null , phonenumber : canSeePhoneNumber (currentUser , user .team) ? user .phonenumber : null , } } By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales. Good to know : There are a couple of different ways you can define a DTO, from using toJSON() , to individual functions like the example above, or JS classes. Since these are JavaScript patterns and not a React or Next.js feature, we recommend doing some research to find the best pattern for your application. Learn more about security best practices in our Security in Next.js article . Server Components Auth check in Server Components are useful for role-based access. For example, to conditionally render components based on the user's role: app/dashboard/page.tsx TypeScript JavaScript TypeScript import { verifySession } from '@/app/lib/dal' export default async function Dashboard () { const session = await verifySession () const userRole = session ?. user ?.role // Assuming 'role' is part of the session object if (userRole === 'admin' ) { return < AdminDashboard /> } else if (userRole === 'user' ) { return < UserDashboard /> } else { redirect ( '/login' ) } } In the example, we use the verifySession() function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role. Layouts and auth checks Due to Partial Rendering , be cautious when doing checks in Layouts as these don't re-render on navigation, meaning the user session won't be checked on every route change. Instead, you should do the checks close to your data source or the component that'll be conditionally rendered. For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data ( getUser() ) in the layout and do the auth check in your DAL. This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data. app/layout.tsx TypeScript JavaScript TypeScript export default async function Layout ({ children , } : { children : React . ReactNode ; }) { const user = await getUser (); return ( // ... ) } app/lib/dal.ts TypeScript JavaScript TypeScript export const getUser = cache ( async () => { const session = await verifySession () if ( ! session) return null // Get user ID from session and fetch data }) Good to know: A common pattern in SPAs is to return null in a layout or a top-level component if a user is not authorized. This pattern is not recommended since Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed. Server Actions Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation. In the example below, we check the user's role before allowing the action to proceed: app/lib/actions.ts TypeScript JavaScript TypeScript 'use server' import { verifySession } from '@/app/ lib /dal' export async function serverAction (formData : FormData ) { const session = await verifySession () const userRole = session ?. user ?.role // Return early if user is not authorized to perform the action if (userRole !== 'admin' ) { return null } // Proceed with the action for authorized users } Route Handlers Treat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler. For example: app/api/route.ts TypeScript JavaScript TypeScript import { verifySession } from '@/app/lib/dal' export async function GET () { // User authentication and role verification const session = await verifySession () // Check if the user is authenticated if ( ! session) { // User is not authenticated return new Response ( null , { status : 401 }) } // Check if the user has the 'admin' role if ( session . user .role !== 'admin' ) { // User is authenticated but does not have the right permissions return new Response ( null , { status : 403 }) } // Continue for authorized users } The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. Context Providers Using context providers for auth works due to interleaving . However, React context is not supported in Server Components, making them only applicable to Client Components. This works, but any child Server Components will be rendered on the server first, and will not have access to the context provider’s session data: app/layout.ts TypeScript JavaScript TypeScript import { ContextProvider } from 'auth-lib' export default function RootLayout ({ children }) { return ( < html lang = "en" > < body > < ContextProvider >{children}</ ContextProvider > </ body > </ html > ) } 'use client' ; import { useSession } from "auth-lib" ; export default function Profile () { const { userId } = useSession (); const { data } = useSWR ( `/api/user/ ${ userId } ` , fetcher) return ( // ... ); } If session data is needed in Client Components (e.g. for client-side data fetching), use React’s taintUniqueValue API to prevent sensitive session data from being exposed to the client. Resources Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management: Auth Libraries Auth0 Better Auth Clerk Kinde Logto NextAuth.js Ory Stack Auth Supabase Stytch WorkOS Session Management Libraries Iron Session Jose Further Reading To continue learning about authentication and security, check out the following resources: How to think about security in Next.js Understanding XSS Attacks Understanding CSRF Attacks The Copenhagen Book Previous Analytics Next Backend for Frontend Was this helpful? supported. Send

---

## 40. Guides: Upgrading | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 41. Getting Started: Error Handling | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://...
```

### Anti-Patterns
- ❌ using try / catch blocks and throw errors. Instead, model expected errors as return values. app/actions.ts TypeScript JavaScript TypeScript 'use server' export async function createPost (prevState : any , formData : FormData ) { const title = formData .get ( 'title' ) const content = formData .get ( 'content' ) const res = await fetch ( 'https://api.vercel.app/posts' , { method : 'POST' , body : { title , content } , }) const json = await res .json () if ( ! res .ok) { return { message : 'Failed to create post' } } } You can pass your action to the useActionState hook and use the returned state to display an error message. app/ui/form.tsx TypeScript JavaScript TypeScript 'use client' import { useActionState } from 'react' import { createPost } from '@/app/actions' const initialState = { message : '' , } export function Form () { const [ state , formAction , pending ] = useActionState (createPost , initialState) return ( < form action = {formAction}> < label htmlFor = "title" >Title</ label > < input type = "text" id = "title" name = "title" req ui red /> < label htmlFor = "content" >Content</ label > < textarea id = "content" name = "content" req ui red /> { state ?.message && < p aria-live = "polite" >{ state .message}</ p >} < button disabled = {pending}>Create Post</ button > </ form > ) } Server Components When fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect . app/page.tsx TypeScript JavaScript TypeScript export default async function Page () { const res = await fetch ( `https://...` ) const data = await res .json () if ( ! res .ok) { return 'There was an error.' } return '...' } Not found You can call the notFound function within a route segment and use the not-found.js file to show a 404 UI. app/blog/[slug]/page.tsx TypeScript JavaScript TypeScript import { getPostBySlug } from '@/lib/posts' export default async function Page ({ params } : { params : { slug : string } }) { const { slug } = await params const post = getPostBySlug (slug) if ( ! post) { notFound () } return < div >{ post .title}</ div > } app/blog/[slug]/not-found.tsx TypeScript JavaScript TypeScript export default function NotFound () { return < div >404 - Page Not Found</ div > } Handling uncaught exceptions Uncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries. Nested error boundaries Next.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed. Create an error boundary by adding an error.js file inside a route segment and exporting a React component: app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components import { useEffect } from 'react' export default function Error ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { useEffect (() => { // Log the error to an error reporting service console .error (error) } , [error]) return ( < div > < h2 >Something went wrong!</ h2 > < button onClick = { // Attempt to recover by trying to re-render the segment () => reset () } > Try again </ button > </ div > ) } Errors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy . Error boundaries don’t catch errors inside event handlers. They’re designed to catch errors during rendering to show a fallback UI instead of crashing the whole app. In general, errors in event handlers or async code aren’t handled by error boundaries because they run after rendering. To handle these cases, catch the error manually and store it using useState or useReducer , then update the UI to inform the user. 'use client' import { useState } from 'react' export function Button () { const [ error , setError ] = useState ( null ) const handleClick = () => { try { // do some work that might fail throw new Error ( 'Exception' ) } catch (reason) { setError (reason) } } if (error) { /* render fallback UI */ } return ( < button type = "button" onClick = {handleClick}> Click me </ button > ) } Note that unhandled errors inside startTransition from useTransition , will bubble up to the nearest error boundary. 'use client' import { useTransition } from 'react' export function Button () { const [ pending , startTransition ] = useTransition () const handleClick = () => startTransition (() => { throw new Error ( 'Exception' ) }) return ( < button type = "button" onClick = {handleClick}> Click me </ button > ) } Global errors While less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization . Global error UI must define its own <html> and <body> tags, since it is replacing the root layout or template when active. app/global-error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function GlobalError ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( // global-error must include html and body tags < html > < body > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ body > </ html > ) } API Reference Learn more about the features mentioned in this page by reading the API Reference. redirect API Reference for the redirect function. error.js API reference for the error.js special file. notFound API Reference for the notFound function. not-found.js API reference for the not-found.js file. Previous Caching and Revalidating Next CSS Was this helpful? supported. Send

---

## 42. File-system conventions: error.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ leaking potentially sensitive details included in the error to the client. error.message Errors forwarded from Client Components show the original Error message. Errors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, under errors.digest , to match the corresponding server-side logs. error.digest An automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs. reset The cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue. An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render. app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function Error ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( < div > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ div > ) } Examples Global Error While less common, you can handle errors in the root layout or template using global-error.jsx , located in the root app directory, even when leveraging internationalization . Global error UI must define its own <html> and <body> tags, global styles, fonts, or other dependencies that your error page requires. This file replaces the root layout or template when active. Good to know : Error boundaries must be Client Components , which means that metadata and generateMetadata exports are not supported in global-error.jsx . As an alternative, you can use the React <title> component. app/global-error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function GlobalError ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( // global-error must include html and body tags < html > < body > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ body > </ html > ) } Graceful error recovery with a custom error boundary When rendering fails on the client, it can be useful to show the last known server rendered UI for a better user experience. The GracefullyDegradingErrorBoundary is an example of a custom error boundary that captures and preserves the current HTML before an error occurs. If a rendering error happens, it re-renders the captured HTML and displays a persistent notification bar to inform the user. app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' import React , { Component , ErrorInfo , ReactNode } from 'react' interface ErrorBoundaryProps { children : ReactNode onError ?: (error : Error , errorInfo : ErrorInfo ) => void } interface ErrorBoundaryState { hasError : boolean } export class GracefullyDegradingErrorBoundary extends Component < ErrorBoundaryProps , ErrorBoundaryState > { private contentRef : React . RefObject < HTMLDivElement > constructor (props : ErrorBoundaryProps ) { super (props) this .state = { hasError : false } this .contentRef = React .createRef () } static getDerivedStateFromError (_ : Error ) : ErrorBoundaryState { return { hasError : true } } componentDidCatch (error : Error , errorInfo : ErrorInfo ) { if ( this . props .onError) { this . props .onError (error , errorInfo) } } render () { if ( this . state .hasError) { // Render the current HTML content without hydration return ( <> < div ref = { this .contentRef} suppressHydrationWarning dangerouslySetInnerHTML = {{ __html : this . contentRef . current ?.innerHTML || '' , }} /> < div className = "fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center" > < p className = "font-semibold" > An error occurred during page rendering </ p > </ div > </> ) } return < div ref = { this .contentRef}>{ this . props .children}</ div > } } export default GracefullyDegradingErrorBoundary Version History Version Changes v15.2.0 Also display global-error in development. v13.1.0 global-error introduced. v13.0.0 error introduced. Learn more about error handling Error Handling Learn how to display expected errors and handle uncaught exceptions. Previous Dynamic Segments Next forbidden.js Was this helpful? supported. Send

---

## 43. File-system conventions: not-found.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 44. Getting Started: Deploying | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 45. Guides: Static Exports | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
/me/index.html
```

```typescript
https://jsonplaceholder.typicode.com/posts/1
```

```typescript
w_ ${ width } 
```

```typescript
q_ ${ quality || 'auto' } 
```

```typescript
https://res.cloudinary.com/demo/image/upload/ ${ params .join ( ',' ) }${ src } 
```

### Anti-Patterns
- ❌ loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads. Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. Configuration To enable a static export, change the output mode inside next.config.js : next.config.js /** * @type {import('next').NextConfig} */ const nextConfig = { output : 'export' , // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html` // trailingSlash: true, // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href` // skipTrailingSlashRedirect: true, // Optional: Change the output directory `out` -> `dist` // distDir: 'dist', } module . exports = nextConfig After running next build , Next.js will create an out folder with the HTML/CSS/JS assets for your application. Supported Features The core of Next.js has been designed to support static exports. Server Components When you run next build to generate a static export, Server Components consumed inside the app directory will run during the build, similar to traditional static-site generation. The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consume dynamic server functions . app/page.tsx TypeScript JavaScript TypeScript export default async function Page () { // This fetch will run on the server during `next build` const res = await fetch ( 'https://api.example.com/...' ) const data = await res .json () return < main >...</ main > } Client Components If you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests. app/other/page.tsx TypeScript JavaScript TypeScript 'use client' import useSWR from 'swr' const fetcher = (url : string ) => fetch (url) .then ((r) => r .json ()) export default function Page () { const { data , error } = useSWR ( `https://jsonplaceholder.typicode.com/posts/1` , fetcher ) if (error) return 'Failed to load' if ( ! data) return 'Loading...' return data .title } Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client: app/page.tsx TypeScript JavaScript TypeScript import Link from 'next/link' export default function Page () { return ( <> < h1 >Index Page</ h1 > < hr /> < ul > < li > < Link href = "/post/1" >Post 1</ Link > </ li > < li > < Link href = "/post/2" >Post 2</ Link > </ li > </ ul > </> ) } Image Optimization Image Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js . For example, you can optimize images with a service like Cloudinary: next.config.js /** @type {import('next').NextConfig} */ const nextConfig = { output : 'export' , images : { loader : 'custom' , loaderFile : './my-loader.ts' , } , } module . exports = nextConfig This custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary: my-loader.ts TypeScript JavaScript TypeScript export default function cloudinaryLoader ({ src , width , quality , } : { src : string width : number quality ?: number }) { const params = [ 'f_auto' , 'c_limit' , `w_ ${ width } ` , `q_ ${ quality || 'auto' } ` ] return `https://res.cloudinary.com/demo/image/upload/ ${ params .join ( ',' ) }${ src } ` } You can then use next/image in your application, defining relative paths to the image in Cloudinary: app/page.tsx TypeScript JavaScript TypeScript import Image from 'next/image' export default function Page () { return < Image alt = "turtles" src = "/turtles.jpg" width = { 300 } height = { 300 } /> } Route Handlers Route Handlers will render a static response when running next build . Only the GET HTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example: app/data.json/route.ts TypeScript JavaScript TypeScript export async function GET () { return Response .json ({ name : 'Lee' }) } The above file app/data.json/route.ts will render to a static file during next build , producing data.json containing { name: 'Lee' } . If you need to read dynamic values from the incoming request, you cannot use a static export. Browser APIs Client Components are pre-rendered to HTML during next build . Because Web APIs like window , localStorage , and navigator are not available on the server, you need to safely access these APIs only when running in the browser. For example: 'use client' ; import { useEffect } from 'react' ; export default function ClientComponent () { useEffect (() => { // You now have access to `window` console .log ( window .innerHeight); } , []) return ... ; } Unsupported Features Features that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported: Dynamic Routes with dynamicParams: true Dynamic Routes without generateStaticParams() Route Handlers that rely on Request Cookies Rewrites Redirects Headers Middleware Incremental Static Regeneration Image Optimization with the default loader Draft Mode Server Actions Intercepting Routes Attempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the root layout. export const dynamic = 'error' Deploying With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. When running next build , Next.js generates the static export into the out folder. For example, let's say you have the following routes: / /blog/[id] After running next build , Next.js will generate the following files: /out/index.html /out/404.html /out/blog/post-1.html /out/blog/post-2.html If you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files: nginx.conf server { listen 80; server_name acme.com; root /var/www/out; location / { try_files $uri $uri.html $uri/ =404 ; } # This is necessary when `trailingSlash: false`. # You can omit this when `trailingSlash: true`. location /blog/ { rewrite ^/blog/(.*)$ /blog/$1.html break ; } error_page 404 /404.html; location = /404.html { internal ; } } Version History Version Changes v14.0.0 next export has been removed in favor of "output": "export" v13.4.0 App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers. v13.3.0 next export is deprecated and replaced with "output": "export" Previous SPAs Next Tailwind CSS v3 Was this helpful? supported. Send

---

## 46. Getting Started: Deploying | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

