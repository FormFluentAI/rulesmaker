---
description: Testing strategies for Next.js applications
globs:
- '**/*.test.*'
- '**/*.spec.*'
- '**/__tests__/**/*'
- '**/tests/**/*'
alwaysApply: false
tags:
- composition-patterns
- building-your-application
- styling
- docs
- css
- server-components
- rendering
- javascript
- forms-and-mutations
- api-reference
version: 1.0.0
lastUpdated: '2025-09-03T07:06:52.416106'
---
# Testing Development Rules
*Generated on 2025-09-03 07:06:52*
## Overview
Testing strategies for Next.js applications
**Difficulty Level**: Beginner
**Category**: testing

## 1. Getting Started: Partial Prerendering | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ depend on request-time data. Dynamic Rendering With Dynamic Rendering, HTML is generated at request time . This allows you to serve personalized content based on request-time data. A component becomes dynamic if it uses the following APIs: cookies headers connection draftMode searchParams prop unstable_noStore fetch with { cache: 'no-store' } In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a Suspense boundary to wrap your component to defer rendering until runtime. Suspense React Suspense is used to defer rendering parts of your application until some condition is met. In Partial Prerendering, Suspense is used to mark dynamic boundaries in your component tree. At build time, Next.js prerenders the static content and the fallback UI. The dynamic content is postponed until the user requests the route. Wrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable streaming app/page.js import { Suspense } from 'react' import StaticComponent from './StaticComponent' import DynamicComponent from './DynamicComponent' import Fallback from './Fallback' export const experimental_ppr = true export default function Page () { return ( <> < StaticComponent /> < Suspense fallback = {< Fallback />}> < DynamicComponent /> </ Suspense > </> ) } Streaming Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. In Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel. To reduce network overhead, the full response—including static HTML and streamed dynamic parts—is sent in a single HTTP request . This avoids extra roundtrips and improves both initial load and overall performance. Enabling Partial Prerendering You can enable PPR by adding the ppr option to your next.config.ts file: next.config.ts TypeScript JavaScript TypeScript import type { NextConfig } from 'next' const nextConfig : NextConfig = { experimental : { ppr : 'incremental' , } , } export default nextConfig The 'incremental' value allows you to adopt PPR for specific routes: /app/dashboard/layout.tsx TypeScript JavaScript TypeScript export const experimental_ppr = true export default function Layout ({ children } : { children : React . ReactNode }) { // ... } Routes that don't have experimental_ppr will default to false and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route. Good to know : experimental_ppr will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route. To disable PPR for children segments, you can set experimental_ppr to false in the child segment. Examples Dynamic APIs When using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the <User /> component is dynamic because it uses the cookies API: app/user.tsx TypeScript JavaScript TypeScript import { cookies } from 'next/headers' export async function User () { const session = ( await cookies ()) .get ( 'session' )?.value return '...' } The <User /> component will be streamed while any other content inside <Page /> will be prerendered and become part of the static shell. app/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import { User , AvatarSkeleton } from './user' export const experimental_ppr = true export default function Page () { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< AvatarSkeleton />}> < User /> </ Suspense > </ section > ) } Passing dynamic props Components only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop: app/page.tsx TypeScript JavaScript TypeScript import { Table , TableSkeleton } from './table' import { Suspense } from 'react' export default function Page ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< TableSkeleton />}> < Table searchParams = {searchParams} /> </ Suspense > </ section > ) } Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be prerendered. app/table.tsx TypeScript JavaScript TypeScript export async function Table ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { const sort = ( await searchParams).sort === 'true' return '...' } Next Steps Learn more about the config option for Partial Prerendering. ppr Learn how to enable Partial Prerendering in Next.js. Previous Server and Client Components Next Fetching Data Was this helpful? supported. Send

---

## 2. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 3. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 4. Getting Started: Server and Client Components | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ need to add the directive to every component that is intended for the client. Reducing JS bundle size To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components. For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component. app/layout.tsx TypeScript JavaScript TypeScript // Client Component import Search from './search' // Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout ({ children } : { children : React . ReactNode }) { return ( <> < nav > < Logo /> < Search /> </ nav > < main >{children}</ main > </> ) } app/ui/search.tsx TypeScript JavaScript TypeScript 'use client' export default function Search () { // ... } Passing data from Server to Client Components You can pass data from Server Components to Client Components using props. app/[id]/page.tsx TypeScript JavaScript TypeScript import LikeButton from '@/app/ui/like-button' import { getPost } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params const post = await getPost (id) return < LikeButton likes = { post .likes} /> } app/ui/like-button.tsx TypeScript JavaScript TypeScript 'use client' export default function LikeButton ({ likes } : { likes : number }) { // ... } Alternatively, you can stream data from a Server Component to a Client Component with the use Hook . See an example . Good to know : Props passed to Client Components need to be serializable by React. Interleaving Server and Client Components You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components. A common pattern is to use children to create a slot in a <ClientComponent> . For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility. app/ui/modal.tsx TypeScript JavaScript TypeScript 'use client' export default function Modal ({ children } : { children : React . ReactNode }) { return < div >{children}</ div > } Then, in a parent Server Component (e.g. <Page> ), you can pass a <Cart> as the child of the <Modal> : app/page.tsx TypeScript JavaScript TypeScript import Modal from './ui/modal' import Cart from './ui/cart' export default function Page () { return ( < Modal > < Cart /> </ Modal > ) } In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree. Context providers React context is commonly used to share global state like the current theme. However, React context is not supported in Server Components. To use context, create a Client Component that accepts children : app/theme-provider.tsx TypeScript JavaScript TypeScript 'use client' import { createContext } from 'react' export const ThemeContext = createContext ({}) export default function ThemeProvider ({ children , } : { children : React . ReactNode }) { return < ThemeContext.Provider value = "dark" >{children}</ ThemeContext.Provider > } Then, import it into a Server Component (e.g. layout ): app/layout.tsx TypeScript JavaScript TypeScript import ThemeProvider from './theme-provider' export default function RootLayout ({ children , } : { children : React . ReactNode }) { return ( < html > < body > < ThemeProvider >{children}</ ThemeProvider > </ body > </ html > ) } Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context. Good to know : You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components. Third-party components When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected. For example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState , but it doesn't yet have the "use client" directive. If you use <Carousel /> within a Client Component, it will work as expected: app/gallery.tsx TypeScript JavaScript TypeScript 'use client' import { useState } from 'react' import { Carousel } from 'acme-carousel' export default function Gallery () { const [ isOpen , setIsOpen ] = useState ( false ) return ( < div > < button onClick = {() => setIsOpen ( true )}>View pictures</ button > { /* Works, since Carousel is used within a Client Component */ } {isOpen && < Carousel />} </ div > ) } However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features. To fix this, you can wrap third-party components that rely on client-only features in your own Client Components: app/carousel.tsx TypeScript JavaScript TypeScript 'use client' import { Carousel } from 'acme-carousel' export default Carousel Now, you can use <Carousel /> directly within a Server Component: app/page.tsx TypeScript JavaScript TypeScript import Carousel from './carousel' export default function Page () { return ( < div > < p >View pictures</ p > { /*  Works, since Carousel is a Client Component */ } < Carousel /> </ div > ) } Advice for Library Authors If you’re building a component library, add the "use client" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers. It's worth noting some bundlers might strip out "use client" directives. You can find an example of how to configure esbuild to include the "use client" directive in the React Wrap Balancer and Vercel Analytics repositories. Preventing environment poisoning JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function: lib/data.ts TypeScript JavaScript TypeScript export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } This function contains an API_KEY that should never be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send
- ❌ be exposed to the client. In Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string. As a result, even though getData() can be imported and executed on the client, it won't work as expected. To prevent accidental usage in Client Components, you can use the server-only package . Then, import the package into a file that contains server-only code: lib/data.js import 'server-only' export async function getData () { const res = await fetch ( 'https://external-service.com/data' , { headers : { authorization : process . env . API_KEY , } , }) return res .json () } Now, if you try to import the module into a Client Component, there will be a build-time error. The corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object. In Next.js, installing server-only or client-only is optional . However, if your linting rules flag extraneous dependencies, you may install them to avoid issues. pnpm npm yarn bun Terminal pnpm add server-only Next.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js. Next.js also provides its own type declarations for server-only and client-only , for TypeScript configurations where noUncheckedSideEffectImports is active. Next Steps Learn more about the APIs mentioned in this page. use client Learn how to use the use client directive to render a component on the client. Previous Linking and Navigating Next Partial Prerendering Was this helpful? supported. Send

---

## 5. Getting Started: Partial Prerendering | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ depend on request-time data. Dynamic Rendering With Dynamic Rendering, HTML is generated at request time . This allows you to serve personalized content based on request-time data. A component becomes dynamic if it uses the following APIs: cookies headers connection draftMode searchParams prop unstable_noStore fetch with { cache: 'no-store' } In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a Suspense boundary to wrap your component to defer rendering until runtime. Suspense React Suspense is used to defer rendering parts of your application until some condition is met. In Partial Prerendering, Suspense is used to mark dynamic boundaries in your component tree. At build time, Next.js prerenders the static content and the fallback UI. The dynamic content is postponed until the user requests the route. Wrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable streaming app/page.js import { Suspense } from 'react' import StaticComponent from './StaticComponent' import DynamicComponent from './DynamicComponent' import Fallback from './Fallback' export const experimental_ppr = true export default function Page () { return ( <> < StaticComponent /> < Suspense fallback = {< Fallback />}> < DynamicComponent /> </ Suspense > </> ) } Streaming Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering. In Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel. To reduce network overhead, the full response—including static HTML and streamed dynamic parts—is sent in a single HTTP request . This avoids extra roundtrips and improves both initial load and overall performance. Enabling Partial Prerendering You can enable PPR by adding the ppr option to your next.config.ts file: next.config.ts TypeScript JavaScript TypeScript import type { NextConfig } from 'next' const nextConfig : NextConfig = { experimental : { ppr : 'incremental' , } , } export default nextConfig The 'incremental' value allows you to adopt PPR for specific routes: /app/dashboard/layout.tsx TypeScript JavaScript TypeScript export const experimental_ppr = true export default function Layout ({ children } : { children : React . ReactNode }) { // ... } Routes that don't have experimental_ppr will default to false and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route. Good to know : experimental_ppr will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route. To disable PPR for children segments, you can set experimental_ppr to false in the child segment. Examples Dynamic APIs When using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the <User /> component is dynamic because it uses the cookies API: app/user.tsx TypeScript JavaScript TypeScript import { cookies } from 'next/headers' export async function User () { const session = ( await cookies ()) .get ( 'session' )?.value return '...' } The <User /> component will be streamed while any other content inside <Page /> will be prerendered and become part of the static shell. app/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import { User , AvatarSkeleton } from './user' export const experimental_ppr = true export default function Page () { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< AvatarSkeleton />}> < User /> </ Suspense > </ section > ) } Passing dynamic props Components only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop: app/page.tsx TypeScript JavaScript TypeScript import { Table , TableSkeleton } from './table' import { Suspense } from 'react' export default function Page ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { return ( < section > < h1 >This will be prerendered</ h1 > < Suspense fallback = {< TableSkeleton />}> < Table searchParams = {searchParams} /> </ Suspense > </ section > ) } Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be prerendered. app/table.tsx TypeScript JavaScript TypeScript export async function Table ({ searchParams , } : { searchParams : Promise <{ sort : string }> }) { const sort = ( await searchParams).sort === 'true' return '...' } Next Steps Learn more about the config option for Partial Prerendering. ppr Learn how to enable Partial Prerendering in Next.js. Previous Server and Client Components Next Fetching Data Was this helpful? supported. Send

---

## 6. Getting Started: Fetching Data | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://api.example.com/ artist / ${ username } 
```

```typescript
https://api.example.com/ artist / ${ username } /albums
```

### Anti-Patterns
- ❌ await the data fetching function const posts = getPosts () return ( < Suspense fallback = {< div >Loading...</ div >}> < Posts posts = {posts} /> </ Suspense > ) } Then, in your Client Component, use the use hook to read the promise: app/ui/posts.tsx TypeScript JavaScript TypeScript 'use client' import { use } from 'react' export default function Posts ({ posts , } : { posts : Promise <{ id : string ; title : string }[]> }) { const allPosts = use (posts) return ( < ul > { allPosts .map ((post) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } In the example above, the <Posts> component is wrapped in a <Suspense> boundary . This means the fallback will be shown while the promise is being resolved. Learn more about streaming . Community libraries You can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR: app/blog/page.tsx TypeScript JavaScript TypeScript 'use client' import useSWR from 'swr' const fetcher = (url) => fetch (url) .then ((r) => r .json ()) export default function BlogPage () { const { data , error , isLoading } = useSWR ( 'https://api.vercel.app/ blog ' , fetcher ) if (isLoading) return < div >Loading...</ div > if (error) return < div >Error: { error .message}</ div > return ( < ul > { data .map ((post : { id : string ; title : string }) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } Deduplicate requests and cache data One way to deduplicate fetch requests is with request memoization . With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch . Request memoization is scoped to the lifetime of a request. You can also deduplicate fetch requests by using Next.js’ Data Cache , for example by setting cache: 'force-cache' in your fetch options. Data Cache allows sharing data across the current render pass and incoming requests. If you are not using fetch , and instead using an ORM or database directly, you can wrap your data access with the React cache function. app/lib/data.ts TypeScript JavaScript TypeScript import { cache } from 'react' import { db , posts , eq } from '@/ lib /db' export const getPost = cache ( async (id : string ) => { const post = await db . query . posts .findFirst ({ where : eq ( posts .id , parseInt (id)) , }) }) Streaming Warning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary. When using async/await in Server Components, Next.js will opt into dynamic rendering . This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering. To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client. There are two ways you can implement streaming in your application: Wrapping a page with a loading.js file Wrapping a component with <Suspense> With loading.js You can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js , add the file inside the app/blog folder. app/blog/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { // Define the Loading UI here return < div >Loading...</ div > } On navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete. Behind-the-scenes, loading.js will be nested inside layout.js , and will automatically wrap the page.js file and any children below in a <Suspense> boundary. This approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense> . With <Suspense> <Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary. app/blog/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import BlogList from '@/components/BlogList' import BlogListSkeleton from '@/components/BlogListSkeleton' export default function BlogPage () { return ( < div > { /* This content will be sent to the client immediately */ } < header > < h1 >Welcome to the Blog</ h1 > < p >Read the latest posts below.</ p > </ header > < main > { /* Any content wrapped in a <Suspense> boundary will be streamed */ } < Suspense fallback = {< BlogListSkeleton />}> < BlogList /> </ Suspense > </ main > </ div > ) } Creating meaningful loading states An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. In development, you can preview and inspect the loading state of your components using the React Devtools . Examples Sequential data fetching Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated , leading to longer response times. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Get artist information const artist = await getArtist (username) return ( <> < h1 >{ artist .name}</ h1 > { /* Show fallback UI while the Playlists component is loading */ } < Suspense fallback = {< div >Loading...</ div >}> { /* Pass the artist ID to the Playlists component */ } < Playlists artist ID = { artist .id} /> </ Suspense > </> ) } async function Playlists ({ artist ID } : { artist ID : string }) { // Use the artist ID to fetch playlists const playlists = await getArtistPlaylists ( artist ID) return ( < ul > { playlists .map ((playlist) => ( < li key = { playlist .id}>{ playlist .name}</ li > ))} </ ul > ) } To improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests. Parallel data fetching Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time. By default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible. However, within any component, multiple async / await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import { getArtist , getAlbums } from '@/app/lib/data' export default async function Page ({ params }) { // These requests will be sequential const { username } = await params const artist = await getArtist (username) const albums = await getAlbums (username) return < div >{ artist .name}</ div > } Start multiple requests by calling fetch , then await them with Promise.all . Requests begin as soon as fetch is called. app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import Albums from './albums' async function getArtist (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } ` ) return res .json () } async function getAlbums (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } /albums` ) return res .json () } export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Initiate requests const artist Data = getArtist (username) const albumsData = getAlbums (username) const [ artist , albums ] = await Promise .all ([ artist Data , albumsData]) return ( <> < h1 >{ artist .name}</ h1 > < Albums list = {albums} /> </> ) } Good to know: If one request fails when using Promise.all , the entire operation will fail. To handle this, you can use the Promise.allSettled method instead. Preloading data You can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function. You can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched. app/item/[id]/page.tsx TypeScript JavaScript TypeScript import { getItem , checkIsAvailable } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params // starting loading item data preload (id) // perform another asynchronous task const isAvailable = await checkIsAvailable () return isAvailable ? < Item id = {id} /> : null } export const preload = (id : string ) => { // void evaluates the given expression and returns undefined // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void void getItem (id) } export async function Item ({ id } : { id : string }) { const result = await getItem (id) // ... } Additionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server. utils/get-item.ts TypeScript JavaScript TypeScript import { cache } from 'react' import 'server-only' import { getItem } from '@/lib/data' export const preload = (id : string ) => { void getItem (id) } export const getItem = cache ( async (id : string ) => { // ... }) API Reference Learn more about the features mentioned in this page by reading the API Reference. Data Security Learn the built-in data security features in Next.js and learn best practices for protecting your application's data. fetch API reference for the extended fetch function. loading.js API reference for the loading.js file. logging Configure how data fetches are logged to the console when running Next.js in development mode. taint Enable tainting Objects and Values. Previous Partial Prerendering Next Updating Data Was this helpful? supported. Send

---

## 7. Getting Started: Fetching Data | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://api.example.com/ artist / ${ username } 
```

```typescript
https://api.example.com/ artist / ${ username } /albums
```

### Anti-Patterns
- ❌ await the data fetching function const posts = getPosts () return ( < Suspense fallback = {< div >Loading...</ div >}> < Posts posts = {posts} /> </ Suspense > ) } Then, in your Client Component, use the use hook to read the promise: app/ui/posts.tsx TypeScript JavaScript TypeScript 'use client' import { use } from 'react' export default function Posts ({ posts , } : { posts : Promise <{ id : string ; title : string }[]> }) { const allPosts = use (posts) return ( < ul > { allPosts .map ((post) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } In the example above, the <Posts> component is wrapped in a <Suspense> boundary . This means the fallback will be shown while the promise is being resolved. Learn more about streaming . Community libraries You can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR: app/blog/page.tsx TypeScript JavaScript TypeScript 'use client' import useSWR from 'swr' const fetcher = (url) => fetch (url) .then ((r) => r .json ()) export default function BlogPage () { const { data , error , isLoading } = useSWR ( 'https://api.vercel.app/ blog ' , fetcher ) if (isLoading) return < div >Loading...</ div > if (error) return < div >Error: { error .message}</ div > return ( < ul > { data .map ((post : { id : string ; title : string }) => ( < li key = { post .id}>{ post .title}</ li > ))} </ ul > ) } Deduplicate requests and cache data One way to deduplicate fetch requests is with request memoization . With this mechanism, fetch calls using GET or HEAD with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can opt out by passing an Abort signal to fetch . Request memoization is scoped to the lifetime of a request. You can also deduplicate fetch requests by using Next.js’ Data Cache , for example by setting cache: 'force-cache' in your fetch options. Data Cache allows sharing data across the current render pass and incoming requests. If you are not using fetch , and instead using an ORM or database directly, you can wrap your data access with the React cache function. app/lib/data.ts TypeScript JavaScript TypeScript import { cache } from 'react' import { db , posts , eq } from '@/ lib /db' export const getPost = cache ( async (id : string ) => { const post = await db . query . posts .findFirst ({ where : eq ( posts .id , parseInt (id)) , }) }) Streaming Warning: The content below assumes the cacheComponents config option is enabled in your application. The flag was introduced in Next.js 15 canary. When using async/await in Server Components, Next.js will opt into dynamic rendering . This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering. To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client. There are two ways you can implement streaming in your application: Wrapping a page with a loading.js file Wrapping a component with <Suspense> With loading.js You can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js , add the file inside the app/blog folder. app/blog/loading.tsx TypeScript JavaScript TypeScript export default function Loading () { // Define the Loading UI here return < div >Loading...</ div > } On navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete. Behind-the-scenes, loading.js will be nested inside layout.js , and will automatically wrap the page.js file and any children below in a <Suspense> boundary. This approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense> . With <Suspense> <Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary. app/blog/page.tsx TypeScript JavaScript TypeScript import { Suspense } from 'react' import BlogList from '@/components/BlogList' import BlogListSkeleton from '@/components/BlogListSkeleton' export default function BlogPage () { return ( < div > { /* This content will be sent to the client immediately */ } < header > < h1 >Welcome to the Blog</ h1 > < p >Read the latest posts below.</ p > </ header > < main > { /* Any content wrapped in a <Suspense> boundary will be streamed */ } < Suspense fallback = {< BlogListSkeleton />}> < BlogList /> </ Suspense > </ main > </ div > ) } Creating meaningful loading states An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. In development, you can preview and inspect the loading state of your components using the React Devtools . Examples Sequential data fetching Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated , leading to longer response times. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Get artist information const artist = await getArtist (username) return ( <> < h1 >{ artist .name}</ h1 > { /* Show fallback UI while the Playlists component is loading */ } < Suspense fallback = {< div >Loading...</ div >}> { /* Pass the artist ID to the Playlists component */ } < Playlists artist ID = { artist .id} /> </ Suspense > </> ) } async function Playlists ({ artist ID } : { artist ID : string }) { // Use the artist ID to fetch playlists const playlists = await getArtistPlaylists ( artist ID) return ( < ul > { playlists .map ((playlist) => ( < li key = { playlist .id}>{ playlist .name}</ li > ))} </ ul > ) } To improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests. Parallel data fetching Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time. By default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible. However, within any component, multiple async / await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved: app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import { getArtist , getAlbums } from '@/app/lib/data' export default async function Page ({ params }) { // These requests will be sequential const { username } = await params const artist = await getArtist (username) const albums = await getAlbums (username) return < div >{ artist .name}</ div > } Start multiple requests by calling fetch , then await them with Promise.all . Requests begin as soon as fetch is called. app/artist/[username]/page.tsx TypeScript JavaScript TypeScript import Albums from './albums' async function getArtist (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } ` ) return res .json () } async function getAlbums (username : string ) { const res = await fetch ( `https://api.example.com/ artist / ${ username } /albums` ) return res .json () } export default async function Page ({ params , } : { params : Promise <{ username : string }> }) { const { username } = await params // Initiate requests const artist Data = getArtist (username) const albumsData = getAlbums (username) const [ artist , albums ] = await Promise .all ([ artist Data , albumsData]) return ( <> < h1 >{ artist .name}</ h1 > < Albums list = {albums} /> </> ) } Good to know: If one request fails when using Promise.all , the entire operation will fail. To handle this, you can use the Promise.allSettled method instead. Preloading data You can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function. You can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched. app/item/[id]/page.tsx TypeScript JavaScript TypeScript import { getItem , checkIsAvailable } from '@/lib/data' export default async function Page ({ params , } : { params : Promise <{ id : string }> }) { const { id } = await params // starting loading item data preload (id) // perform another asynchronous task const isAvailable = await checkIsAvailable () return isAvailable ? < Item id = {id} /> : null } export const preload = (id : string ) => { // void evaluates the given expression and returns undefined // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void void getItem (id) } export async function Item ({ id } : { id : string }) { const result = await getItem (id) // ... } Additionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server. utils/get-item.ts TypeScript JavaScript TypeScript import { cache } from 'react' import 'server-only' import { getItem } from '@/lib/data' export const preload = (id : string ) => { void getItem (id) } export const getItem = cache ( async (id : string ) => { // ... }) API Reference Learn more about the features mentioned in this page by reading the API Reference. Data Security Learn the built-in data security features in Next.js and learn best practices for protecting your application's data. fetch API reference for the extended fetch function. loading.js API reference for the loading.js file. logging Configure how data fetches are logged to the console when running Next.js in development mode. taint Enable tainting Objects and Values. Previous Partial Prerendering Next Updating Data Was this helpful? supported. Send

---

## 8. Guides: Forms | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 9. Guides: CSS-in-JS | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 10. Guides: Lazy Loading | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

---

## 11. Getting Started: Error Handling | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Examples
```typescript
https://...
```

### Anti-Patterns
- ❌ using try / catch blocks and throw errors. Instead, model expected errors as return values. app/actions.ts TypeScript JavaScript TypeScript 'use server' export async function createPost (prevState : any , formData : FormData ) { const title = formData .get ( 'title' ) const content = formData .get ( 'content' ) const res = await fetch ( 'https://api.vercel.app/posts' , { method : 'POST' , body : { title , content } , }) const json = await res .json () if ( ! res .ok) { return { message : 'Failed to create post' } } } You can pass your action to the useActionState hook and use the returned state to display an error message. app/ui/form.tsx TypeScript JavaScript TypeScript 'use client' import { useActionState } from 'react' import { createPost } from '@/app/actions' const initialState = { message : '' , } export function Form () { const [ state , formAction , pending ] = useActionState (createPost , initialState) return ( < form action = {formAction}> < label htmlFor = "title" >Title</ label > < input type = "text" id = "title" name = "title" req ui red /> < label htmlFor = "content" >Content</ label > < textarea id = "content" name = "content" req ui red /> { state ?.message && < p aria-live = "polite" >{ state .message}</ p >} < button disabled = {pending}>Create Post</ button > </ form > ) } Server Components When fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect . app/page.tsx TypeScript JavaScript TypeScript export default async function Page () { const res = await fetch ( `https://...` ) const data = await res .json () if ( ! res .ok) { return 'There was an error.' } return '...' } Not found You can call the notFound function within a route segment and use the not-found.js file to show a 404 UI. app/blog/[slug]/page.tsx TypeScript JavaScript TypeScript import { getPostBySlug } from '@/lib/posts' export default async function Page ({ params } : { params : { slug : string } }) { const { slug } = await params const post = getPostBySlug (slug) if ( ! post) { notFound () } return < div >{ post .title}</ div > } app/blog/[slug]/not-found.tsx TypeScript JavaScript TypeScript export default function NotFound () { return < div >404 - Page Not Found</ div > } Handling uncaught exceptions Uncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries. Nested error boundaries Next.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed. Create an error boundary by adding an error.js file inside a route segment and exporting a React component: app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components import { useEffect } from 'react' export default function Error ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { useEffect (() => { // Log the error to an error reporting service console .error (error) } , [error]) return ( < div > < h2 >Something went wrong!</ h2 > < button onClick = { // Attempt to recover by trying to re-render the segment () => reset () } > Try again </ button > </ div > ) } Errors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy . Error boundaries don’t catch errors inside event handlers. They’re designed to catch errors during rendering to show a fallback UI instead of crashing the whole app. In general, errors in event handlers or async code aren’t handled by error boundaries because they run after rendering. To handle these cases, catch the error manually and store it using useState or useReducer , then update the UI to inform the user. 'use client' import { useState } from 'react' export function Button () { const [ error , setError ] = useState ( null ) const handleClick = () => { try { // do some work that might fail throw new Error ( 'Exception' ) } catch (reason) { setError (reason) } } if (error) { /* render fallback UI */ } return ( < button type = "button" onClick = {handleClick}> Click me </ button > ) } Note that unhandled errors inside startTransition from useTransition , will bubble up to the nearest error boundary. 'use client' import { useTransition } from 'react' export function Button () { const [ pending , startTransition ] = useTransition () const handleClick = () => startTransition (() => { throw new Error ( 'Exception' ) }) return ( < button type = "button" onClick = {handleClick}> Click me </ button > ) } Global errors While less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization . Global error UI must define its own <html> and <body> tags, since it is replacing the root layout or template when active. app/global-error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function GlobalError ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( // global-error must include html and body tags < html > < body > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ body > </ html > ) } API Reference Learn more about the features mentioned in this page by reading the API Reference. redirect API Reference for the redirect function. error.js API reference for the error.js special file. notFound API Reference for the notFound function. not-found.js API reference for the not-found.js file. Previous Caching and Revalidating Next CSS Was this helpful? supported. Send

---

## 12. File-system conventions: error.js | Next.js
Menu Using App Router Features available in /app Using Latest Version 15.5.2 Getting Started Installation Project Structure Layouts and Pages Linking and Navigating Server and Client Components Partial Prerendering Fetching Data Updating Data Caching and Revalidating Error Handling CSS Image Optimization Font Optimization Metadata and OG images Route Handlers and Middleware Deploying Upgrading Guides Analytics Authentication Backend for Frontend Caching CI Build Caching Content Security Policy C...

### Anti-Patterns
- ❌ leaking potentially sensitive details included in the error to the client. error.message Errors forwarded from Client Components show the original Error message. Errors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, under errors.digest , to match the corresponding server-side logs. error.digest An automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs. reset The cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue. An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render. app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function Error ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( < div > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ div > ) } Examples Global Error While less common, you can handle errors in the root layout or template using global-error.jsx , located in the root app directory, even when leveraging internationalization . Global error UI must define its own <html> and <body> tags, global styles, fonts, or other dependencies that your error page requires. This file replaces the root layout or template when active. Good to know : Error boundaries must be Client Components , which means that metadata and generateMetadata exports are not supported in global-error.jsx . As an alternative, you can use the React <title> component. app/global-error.tsx TypeScript JavaScript TypeScript 'use client' // Error boundaries must be Client Components export default function GlobalError ({ error , reset , } : { error : Error & { digest ?: string } reset : () => void }) { return ( // global-error must include html and body tags < html > < body > < h2 >Something went wrong!</ h2 > < button onClick = {() => reset ()}>Try again</ button > </ body > </ html > ) } Graceful error recovery with a custom error boundary When rendering fails on the client, it can be useful to show the last known server rendered UI for a better user experience. The GracefullyDegradingErrorBoundary is an example of a custom error boundary that captures and preserves the current HTML before an error occurs. If a rendering error happens, it re-renders the captured HTML and displays a persistent notification bar to inform the user. app/dashboard/error.tsx TypeScript JavaScript TypeScript 'use client' import React , { Component , ErrorInfo , ReactNode } from 'react' interface ErrorBoundaryProps { children : ReactNode onError ?: (error : Error , errorInfo : ErrorInfo ) => void } interface ErrorBoundaryState { hasError : boolean } export class GracefullyDegradingErrorBoundary extends Component < ErrorBoundaryProps , ErrorBoundaryState > { private contentRef : React . RefObject < HTMLDivElement > constructor (props : ErrorBoundaryProps ) { super (props) this .state = { hasError : false } this .contentRef = React .createRef () } static getDerivedStateFromError (_ : Error ) : ErrorBoundaryState { return { hasError : true } } componentDidCatch (error : Error , errorInfo : ErrorInfo ) { if ( this . props .onError) { this . props .onError (error , errorInfo) } } render () { if ( this . state .hasError) { // Render the current HTML content without hydration return ( <> < div ref = { this .contentRef} suppressHydrationWarning dangerouslySetInnerHTML = {{ __html : this . contentRef . current ?.innerHTML || '' , }} /> < div className = "fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center" > < p className = "font-semibold" > An error occurred during page rendering </ p > </ div > </> ) } return < div ref = { this .contentRef}>{ this . props .children}</ div > } } export default GracefullyDegradingErrorBoundary Version History Version Changes v15.2.0 Also display global-error in development. v13.1.0 global-error introduced. v13.0.0 error introduced. Learn more about error handling Error Handling Learn how to display expected errors and handle uncaught exceptions. Previous Dynamic Segments Next forbidden.js Was this helpful? supported. Send

---

